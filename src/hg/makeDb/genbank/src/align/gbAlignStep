#!/usr/bin/perl

$main::usage = "
gbAlignStep [options] database ...

Options:
  -initial - Default the parameters for the initial alignment of a genome:
     -workdir=work/initial.$db/align
   Doesn't create a semaphone file and will log to 
      var/build/logs/2003.05.23-21:51:12.$db.initalign.log
   Will not migrate alignments from previous releases.

  -workdir=work/align - work directory where alignment is built.
   This directory must have at least two levels (for use with rsync) for
   example: rest/work2/work1.  Specifying a different parent directory
   (work2) for doing alignments without risking of collision with the
   automatic alignments.  The two levels of directories allows rsync to
   delete older files under the parent directory when the lowest-level
   directory includes the alignment date.  Maybe a longer or fully qualified
   path.

  -clusterRootDir=2dir - The directory where the files will exist on the
   cluster. They will be rsynced to this location on the iserver.  The
   lowest two levels of the workdir are included, resulting, e.g.:
   /dir/work/align.  Overrides cluster.rootDir conf item.

  -paraHub=kk - name of parasol host, must have ssh access.

  -paraPriority=n - parasol priority to use for jobs

  -iserver=host - explictly specify an iservers to use.  Maybe repeated.
   If none are specified, the servers are obtained from the cluster.iserver
   Specify \"no\" when using global file system.

  -continue=subtask - continue processing of a failed alignment run
   of this script.   Values for subtask are:
       - copy - continue with coping to the iserver, this skips
         extracting the sequences to align.
       - run - continue with parasol blat run.
       - finish - finish processing the alignments.
   Continue the blat portion by using parasol directly.
   
  -keep - Keep work directory

  -verbose=n - Set verbose level.

  -srcDb=name - Restrict the source database to either \"genbank\" or \"refseq\".

  -type=name - Restrict the type of sequence processeed to either \"mrna\"
   or \"est\".

  -orgCat=cat - Restrict the organism category of sequences processeed to
   \"native\" or \"xeno\".

Obtains other parameters from etc/genbank.conf.

Alignment step, runs:
 - gbAlignSetup - Extract sequences to align, create jobs files.
 - gbAlignIServerCopy - Copy fasta files to iservers with rsync 
 - gbAlignRun - rsh to kk adn run para make until jobs complete
   checking results.
 - gbAlignFinish - Process PSL files and install in data directory
";

#
# $Id: gbAlignStep,v 1.22 2008/11/21 16:02:09 markd Exp $
#
use strict;
use warnings;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin/../lib";
use gbCommon;

# open /cluster/ directories to avoid automounter problems on
# genbank server results in "Device or resource busy" error
# (FIXME: tmp hack)
use POSIX;
sub holdOpenDir($) {
    my($path) = @_;
    my $fd = POSIX::open($path);
    if (!defined($fd)) {
        die("can't open cluster directory $path");
    }
}
sub openNfsDirsHack() {
    holdOpenDir("/cluster/data");
    holdOpenDir("/cluster/genbank");
    holdOpenDir("/cluster/bin");
}

# Entry
my $workDir;
my $verbArg = "";
my $paraHub;
my $keep = 0;
my $clusterRootDir;
my $clusterWorkDir;
my $localWorkDir;
my @iservers;
my @srcDbs;
my @types;
my @orgCats;
my $initialBuild = 0;
my $continueTask;
my $verbArgl="";
my $paraPriority;
while (($#ARGV >= 0) && ($ARGV[0] =~/^-.*/)) {
    my $opt = $ARGV[0];
    shift @ARGV;
    if ($opt =~ /^-workdir($|=)/) {
        $workDir = parseOptEq($opt);
    } elsif ($opt eq "-initial") {
        $initialBuild = 1;
    } elsif ($opt =~ /^-clusterRootDir($|=)/) {
        $clusterRootDir = parseOptEq($opt);
    } elsif ($opt =~ /^-iserver($|=)/) {
        push(@iservers, parseOptEq($opt));
    } elsif ($opt =~ /^-continue($|=)/) {
        $continueTask = parseOptEq($opt);
    } elsif ($opt eq "-verbose") {
        $gbCommon::verbose = 1;
        $verbArg = "-verbose";
        $verbArgl = "--verbose=1";
    } elsif ($opt =~ /^-verbose=/) {
        $gbCommon::verbose = parseOptEq($opt);
        $verbArg = "-verbose=$gbCommon::verbose";
        $verbArgl = "--verbose=$gbCommon::verbose";
    } elsif ($opt eq "-keep") {
        $keep = 1;
    } elsif ($opt =~ /^-paraHub($|=)/) {
        $paraHub = parseOptEq($opt);
    } elsif ($opt =~ /^-paraPriority($|=)/) {
        $paraPriority = parseOptEq($opt);
    } elsif ($opt =~ /^-srcDb($|=)/) {
        # value check in gbAlignSetup
        my $srcDb = parseOptEq($opt);
        push(@srcDbs, $srcDb);
    } elsif ($opt =~ /^-type($|=)/) {
        # value check in gbAlignSetup
        my $type = parseOptEq($opt);
        push(@types, $type)
    } elsif ($opt =~ /^-orgCat($|=)/) {
        # value check in gbAlignSetup
        my $orgCat = parseOptEq($opt);
        push(@orgCats, $orgCat);
    } else {
        gbError("invalid option \"$opt\"");
    }
}

if ($#ARGV < 0) {
    gbError("wrong # args: $main::usage");
}
my @databases;
while ($#ARGV >= 0) {
    push(@databases, $ARGV[0]);
    shift @ARGV;
}

if (!defined($clusterRootDir)) {
    $clusterRootDir = getConf("cluster.rootDir");
}

# defaults for initial alignment
my $initialDb;
if ($initialBuild) {
    if ($#databases != 0) {
        gbError("only one database maybe specified with -initial");
    }
    $initialDb = $databases[0];
    if (!defined($workDir)) {
        $workDir = "work/initial.$initialDb/align";
    }
}

# need to know if we are using the iservers
my @iserverList = @iservers;
if ($#iserverList < 0) {
    @iserverList = splitSpaceList(getConfNo("cluster.iservers"));
}
my $usingIservers = ($#iserverList >= 0) && ($iserverList[0] ne "no");

# figure out workDir.  If no iservers are used, we write directly
# to cluster dir.
if (!defined($workDir)) {
    $workDir = "work/align";
}
if ($usingIservers) {
    if (dirname($workDir) eq ".") {
        gbError("work directory must have at least two level, got: $workDir");
    }
    # use last two directories in workDir on cluster
    $clusterWorkDir = $clusterRootDir . "/" . basename(dirname($workDir)) . "/"
        . basename($workDir);
    $localWorkDir = $workDir;
} else {
    # not using iservers
    $clusterWorkDir = "$clusterRootDir/$workDir";
    $localWorkDir = $clusterWorkDir;
}
my $workDirArg = "-workdir=$localWorkDir";
my $workDirArgl = "--workdir=$localWorkDir";
my $iserverArg = "";
foreach my $iserver (@iservers) {
    $iserverArg .= " -iserver=$iserver";
}


# convert continue task to a list of task to execute
my @tasks;
if (!defined($continueTask)) {
    @tasks = ("setup", "copy", "run", "finish");
} elsif ($continueTask eq "copy") {
    @tasks = ("copy", "run", "finish");
} elsif ($continueTask eq "run") {
    @tasks = ("run", "finish");
} elsif ($continueTask eq "finish") {
    @tasks = ("finish");
} else {
    gbError("invalid value for -continue, expected one of \"copy\", \"run\", or \"finish\"");
}

my $alignNone = "$localWorkDir/align.none";  # indicates nothing to align
my $alignJobs = "$localWorkDir/align.jobs";
my $alignDone = "$localWorkDir/align.done";

# If TMPDIR is not set, set it to a local directory. /var/tmp doesn't
# usually have enough space, so we use a tmp dir in the gbRoot
if (!defined($main::ENV{TMPDIR})) {
    $main::ENV{TMPDIR} = "tmp";
    makeDir($main::ENV{TMPDIR});
}
checkOnBuildServer();
openNfsDirsHack();

# begin
if ($initialBuild) {
    beginTaskNoLock("build", "$initialDb.initalign");
} else {
    beginTask("build", "align");
}

# setup
if (inList("setup", @tasks)) {
    my $cmd = "gbAlignSetup $workDirArgl $verbArgl";
    if ($initialBuild) {
        $cmd .= " --noMigrate";
    }
    if (defined($clusterRootDir)) {
        $cmd .= " --clusterWorkDir=$clusterWorkDir";
    }
    foreach my $srcDb (@srcDbs) {
        $cmd .= " --srcDb=$srcDb";
    }
    foreach my $type (@types) {
        $cmd .= " --type=$type";
    }
    foreach my $orgCat (@orgCats) {
        $cmd .= " --orgCat=$orgCat";
    }
    
    foreach my $db (@databases) {
        $cmd .= " $db";
    }
    runProg($cmd);

    if (-e $alignNone) {
        prMsg("nothing to align");
    }
}

# Must either have a jobs or none file
if (! (-e $alignNone || -e $alignJobs)) {
    gbError("no $alignJobs or $alignNone file found");
}

# copy if using iservers
if ($usingIservers && inList("copy", @tasks) && !-e $alignNone) {
    # copy to iserver if needed
    if (defined($clusterRootDir)) {
        my $cmd = "gbAlignIServerCopy $verbArg $iserverArg";
        if (defined($clusterRootDir)) {
            $cmd .= " -clusterRootDir=$clusterRootDir";
        }
        $cmd .= " " . $workDir;
        runProg($cmd);
    }
}

# run alignment
if (inList("run", @tasks) && !-e $alignNone) {
    my $cmd = "gbAlignRun $workDirArg $verbArg";
    if (defined($paraHub)) {
        $cmd .= " -paraHub=$paraHub";
    }
    if (defined($paraPriority)) {
        $cmd .= " -paraPriority=$paraPriority";
    }
    runProg($cmd);
}

# If -continue=finish is specified, force the create of a jobs.done file
if (defined($continueTask) && ($continueTask eq "finish")) {
    # finishing by hand, create align.done file.
    open(DONE, ">$alignDone") || die("can't create $alignDone");
    close(DONE) || die("close failed");
}

if (inList("finish", @tasks) && !-e $alignNone) {
    # finish, lift and installing alignments
    my $cmd = "gbAlignFinish $workDirArg $verbArg";
    if ($initialBuild) {
        $cmd .= " -noMigrate";
    }
    foreach my $db (@databases) {
        $cmd .= " $db";
    }
    runProg($cmd);
}
if (!$keep) {
    runProg("rm -rf $localWorkDir");
    my $workParent = dirname($localWorkDir);
    rmdir($workParent);  # don't complain if can't remove
}
endTask();
