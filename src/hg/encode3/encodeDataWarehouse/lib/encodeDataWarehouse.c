/* encodeDataWarehouse.c was originally generated by the autoSql program, which also 
 * generated encodeDataWarehouse.h and encodeDataWarehouse.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "encodeDataWarehouse.h"



char *edwUserCommaSepFieldNames = "id,email";

void edwUserStaticLoad(char **row, struct edwUser *ret)
/* Load a row from edwUser table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->email = row[1];
}

struct edwUser *edwUserLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwUser from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwUserSaveToDb(struct sqlConnection *conn, struct edwUser *el, char *tableName, int updateSize)
/* Save edwUser as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,'%s')", 
	tableName,  el->id,  el->email);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwUser *edwUserLoad(char **row)
/* Load a edwUser from row fetched with select * from edwUser
 * from database.  Dispose of this with edwUserFree(). */
{
struct edwUser *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->email = cloneString(row[1]);
return ret;
}

struct edwUser *edwUserLoadAll(char *fileName) 
/* Load all edwUser from a whitespace-separated file.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileRow(lf, row))
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwUser *edwUserLoadAllByChar(char *fileName, char chopper) 
/* Load all edwUser from a chopper separated file.
 * Dispose of this with edwUserFreeList(). */
{
struct edwUser *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwUserLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwUser *edwUserCommaIn(char **pS, struct edwUser *ret)
/* Create a edwUser out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwUser */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->email = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwUserFree(struct edwUser **pEl)
/* Free a single dynamically allocated edwUser such as created
 * with edwUserLoad(). */
{
struct edwUser *el;

if ((el = *pEl) == NULL) return;
freeMem(el->email);
freez(pEl);
}

void edwUserFreeList(struct edwUser **pList)
/* Free a list of dynamically allocated edwUser's */
{
struct edwUser *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwUserFree(&el);
    }
*pList = NULL;
}

void edwUserOutput(struct edwUser *el, FILE *f, char sep, char lastSep) 
/* Print out edwUser.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->email);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}


char *edwScriptRegistryCommaSepFieldNames = "id,userId,name,description,secretHash,submitCount";

void edwScriptRegistryStaticLoad(char **row, struct edwScriptRegistry *ret)
/* Load a row from edwScriptRegistry table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->userId = sqlUnsigned(row[1]);
ret->name = row[2];
ret->description = row[3];
ret->secretHash = row[4];
ret->submitCount = sqlSigned(row[5]);
}

struct edwScriptRegistry *edwScriptRegistryLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwScriptRegistry from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwScriptRegistryFreeList(). */
{
struct edwScriptRegistry *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwScriptRegistryLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwScriptRegistrySaveToDb(struct sqlConnection *conn, struct edwScriptRegistry *el, char *tableName, int updateSize)
/* Save edwScriptRegistry as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,%u,'%s','%s','%s',%d)", 
	tableName,  el->id,  el->userId,  el->name,  el->description,  el->secretHash,  el->submitCount);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwScriptRegistry *edwScriptRegistryLoad(char **row)
/* Load a edwScriptRegistry from row fetched with select * from edwScriptRegistry
 * from database.  Dispose of this with edwScriptRegistryFree(). */
{
struct edwScriptRegistry *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->userId = sqlUnsigned(row[1]);
ret->name = cloneString(row[2]);
ret->description = cloneString(row[3]);
ret->secretHash = cloneString(row[4]);
ret->submitCount = sqlSigned(row[5]);
return ret;
}

struct edwScriptRegistry *edwScriptRegistryLoadAll(char *fileName) 
/* Load all edwScriptRegistry from a whitespace-separated file.
 * Dispose of this with edwScriptRegistryFreeList(). */
{
struct edwScriptRegistry *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = edwScriptRegistryLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwScriptRegistry *edwScriptRegistryLoadAllByChar(char *fileName, char chopper) 
/* Load all edwScriptRegistry from a chopper separated file.
 * Dispose of this with edwScriptRegistryFreeList(). */
{
struct edwScriptRegistry *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwScriptRegistryLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwScriptRegistry *edwScriptRegistryCommaIn(char **pS, struct edwScriptRegistry *ret)
/* Create a edwScriptRegistry out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwScriptRegistry */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->userId = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->description = sqlStringComma(&s);
ret->secretHash = sqlStringComma(&s);
ret->submitCount = sqlSignedComma(&s);
*pS = s;
return ret;
}

void edwScriptRegistryFree(struct edwScriptRegistry **pEl)
/* Free a single dynamically allocated edwScriptRegistry such as created
 * with edwScriptRegistryLoad(). */
{
struct edwScriptRegistry *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->description);
freeMem(el->secretHash);
freez(pEl);
}

void edwScriptRegistryFreeList(struct edwScriptRegistry **pList)
/* Free a list of dynamically allocated edwScriptRegistry's */
{
struct edwScriptRegistry *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwScriptRegistryFree(&el);
    }
*pList = NULL;
}

void edwScriptRegistryOutput(struct edwScriptRegistry *el, FILE *f, char sep, char lastSep) 
/* Print out edwScriptRegistry.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->userId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->description);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->secretHash);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%d", el->submitCount);
fputc(lastSep,f);
}


char *edwHostCommaSepFieldNames = "id,name,lastOkTime,lastNotOkTime,firstAdded,errorMessage,openSuccesses,openFails,historyBits,paraFetchStreams";

void edwHostStaticLoad(char **row, struct edwHost *ret)
/* Load a row from edwHost table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = row[5];
ret->openSuccesses = sqlLongLong(row[6]);
ret->openFails = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
ret->paraFetchStreams = sqlSigned(row[9]);
}

struct edwHost *edwHostLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwHost from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwHostSaveToDb(struct sqlConnection *conn, struct edwHost *el, char *tableName, int updateSize)
/* Save edwHost as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,'%s',%lld,%lld,%lld,'%s',%lld,%lld,%lld,%d)", 
	tableName,  el->id,  el->name,  el->lastOkTime,  el->lastNotOkTime,  el->firstAdded,  el->errorMessage,  el->openSuccesses,  el->openFails,  el->historyBits,  el->paraFetchStreams);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwHost *edwHostLoad(char **row)
/* Load a edwHost from row fetched with select * from edwHost
 * from database.  Dispose of this with edwHostFree(). */
{
struct edwHost *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->lastOkTime = sqlLongLong(row[2]);
ret->lastNotOkTime = sqlLongLong(row[3]);
ret->firstAdded = sqlLongLong(row[4]);
ret->errorMessage = cloneString(row[5]);
ret->openSuccesses = sqlLongLong(row[6]);
ret->openFails = sqlLongLong(row[7]);
ret->historyBits = sqlLongLong(row[8]);
ret->paraFetchStreams = sqlSigned(row[9]);
return ret;
}

struct edwHost *edwHostLoadAll(char *fileName) 
/* Load all edwHost from a whitespace-separated file.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileRow(lf, row))
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwHost *edwHostLoadAllByChar(char *fileName, char chopper) 
/* Load all edwHost from a chopper separated file.
 * Dispose of this with edwHostFreeList(). */
{
struct edwHost *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwHostLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwHost *edwHostCommaIn(char **pS, struct edwHost *ret)
/* Create a edwHost out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwHost */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->openSuccesses = sqlLongLongComma(&s);
ret->openFails = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
ret->paraFetchStreams = sqlSignedComma(&s);
*pS = s;
return ret;
}

void edwHostFree(struct edwHost **pEl)
/* Free a single dynamically allocated edwHost such as created
 * with edwHostLoad(). */
{
struct edwHost *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->errorMessage);
freez(pEl);
}

void edwHostFreeList(struct edwHost **pList)
/* Free a list of dynamically allocated edwHost's */
{
struct edwHost *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwHostFree(&el);
    }
*pList = NULL;
}

void edwHostOutput(struct edwHost *el, FILE *f, char sep, char lastSep) 
/* Print out edwHost.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->openSuccesses);
fputc(sep,f);
fprintf(f, "%lld", el->openFails);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(sep,f);
fprintf(f, "%d", el->paraFetchStreams);
fputc(lastSep,f);
}


char *edwSubmitDirCommaSepFieldNames = "id,url,hostId,lastOkTime,lastNotOkTime,firstAdded,errorMessage,openSuccesses,openFails,historyBits";

void edwSubmitDirStaticLoad(char **row, struct edwSubmitDir *ret)
/* Load a row from edwSubmitDir table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = row[6];
ret->openSuccesses = sqlLongLong(row[7]);
ret->openFails = sqlLongLong(row[8]);
ret->historyBits = sqlLongLong(row[9]);
}

struct edwSubmitDir *edwSubmitDirLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwSubmitDir from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwSubmitDirFreeList(). */
{
struct edwSubmitDir *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwSubmitDirLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwSubmitDirSaveToDb(struct sqlConnection *conn, struct edwSubmitDir *el, char *tableName, int updateSize)
/* Save edwSubmitDir as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,'%s',%u,%lld,%lld,%lld,'%s',%lld,%lld,%lld)", 
	tableName,  el->id,  el->url,  el->hostId,  el->lastOkTime,  el->lastNotOkTime,  el->firstAdded,  el->errorMessage,  el->openSuccesses,  el->openFails,  el->historyBits);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwSubmitDir *edwSubmitDirLoad(char **row)
/* Load a edwSubmitDir from row fetched with select * from edwSubmitDir
 * from database.  Dispose of this with edwSubmitDirFree(). */
{
struct edwSubmitDir *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->hostId = sqlUnsigned(row[2]);
ret->lastOkTime = sqlLongLong(row[3]);
ret->lastNotOkTime = sqlLongLong(row[4]);
ret->firstAdded = sqlLongLong(row[5]);
ret->errorMessage = cloneString(row[6]);
ret->openSuccesses = sqlLongLong(row[7]);
ret->openFails = sqlLongLong(row[8]);
ret->historyBits = sqlLongLong(row[9]);
return ret;
}

struct edwSubmitDir *edwSubmitDirLoadAll(char *fileName) 
/* Load all edwSubmitDir from a whitespace-separated file.
 * Dispose of this with edwSubmitDirFreeList(). */
{
struct edwSubmitDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileRow(lf, row))
    {
    el = edwSubmitDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmitDir *edwSubmitDirLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmitDir from a chopper separated file.
 * Dispose of this with edwSubmitDirFreeList(). */
{
struct edwSubmitDir *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[10];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmitDirLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmitDir *edwSubmitDirCommaIn(char **pS, struct edwSubmitDir *ret)
/* Create a edwSubmitDir out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmitDir */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->hostId = sqlUnsignedComma(&s);
ret->lastOkTime = sqlLongLongComma(&s);
ret->lastNotOkTime = sqlLongLongComma(&s);
ret->firstAdded = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->openSuccesses = sqlLongLongComma(&s);
ret->openFails = sqlLongLongComma(&s);
ret->historyBits = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwSubmitDirFree(struct edwSubmitDir **pEl)
/* Free a single dynamically allocated edwSubmitDir such as created
 * with edwSubmitDirLoad(). */
{
struct edwSubmitDir *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void edwSubmitDirFreeList(struct edwSubmitDir **pList)
/* Free a list of dynamically allocated edwSubmitDir's */
{
struct edwSubmitDir *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmitDirFree(&el);
    }
*pList = NULL;
}

void edwSubmitDirOutput(struct edwSubmitDir *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmitDir.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->hostId);
fputc(sep,f);
fprintf(f, "%lld", el->lastOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->lastNotOkTime);
fputc(sep,f);
fprintf(f, "%lld", el->firstAdded);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->openSuccesses);
fputc(sep,f);
fprintf(f, "%lld", el->openFails);
fputc(sep,f);
fprintf(f, "%lld", el->historyBits);
fputc(lastSep,f);
}


char *edwFileCommaSepFieldNames = "id,submitId,submitDirId,submitFileName,edwFileName,startUploadTime,endUploadTime,updateTime,size,md5,tags,errorMessage,deprecated,replacedBy";

void edwFileStaticLoad(char **row, struct edwFile *ret)
/* Load a row from edwFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->submitId = sqlUnsigned(row[1]);
ret->submitDirId = sqlUnsigned(row[2]);
ret->submitFileName = row[3];
ret->edwFileName = row[4];
ret->startUploadTime = sqlLongLong(row[5]);
ret->endUploadTime = sqlLongLong(row[6]);
ret->updateTime = sqlLongLong(row[7]);
ret->size = sqlLongLong(row[8]);
safecpy(ret->md5, sizeof(ret->md5), row[9]);
ret->tags = row[10];
ret->errorMessage = row[11];
ret->deprecated = row[12];
ret->replacedBy = sqlUnsigned(row[13]);
}

struct edwFile *edwFileLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwFile from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwFileSaveToDb(struct sqlConnection *conn, struct edwFile *el, char *tableName, int updateSize)
/* Save edwFile as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,%u,%u,'%s','%s',%lld,%lld,%lld,%lld,'%s','%s','%s','%s',%u)", 
	tableName,  el->id,  el->submitId,  el->submitDirId,  el->submitFileName,  el->edwFileName,  el->startUploadTime,  el->endUploadTime,  el->updateTime,  el->size,  el->md5,  el->tags,  el->errorMessage,  el->deprecated,  el->replacedBy);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void edwFileSaveToDbEscaped(struct sqlConnection *conn, struct edwFile *el, char *tableName, int updateSize)
/* Save edwFile as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwFileSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *submitFileName, *edwFileName, *md5, *tags, *errorMessage, *deprecated;
submitFileName = sqlEscapeString(el->submitFileName);
edwFileName = sqlEscapeString(el->edwFileName);
md5 = sqlEscapeString(el->md5);
tags = sqlEscapeString(el->tags);
errorMessage = sqlEscapeString(el->errorMessage);
deprecated = sqlEscapeString(el->deprecated);

sqlDyStringPrintf(update, "insert into %s values ( %u,%u,%u,'%s','%s',%lld,%lld,%lld,%lld,'%s','%s','%s','%s',%u)", 
	tableName,  el->id,  el->submitId,  el->submitDirId,  submitFileName,  edwFileName,  el->startUploadTime,  el->endUploadTime,  el->updateTime,  el->size,  md5,  tags,  errorMessage,  deprecated,  el->replacedBy);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&submitFileName);
freez(&edwFileName);
freez(&md5);
freez(&tags);
freez(&errorMessage);
freez(&deprecated);
}

struct edwFile *edwFileLoad(char **row)
/* Load a edwFile from row fetched with select * from edwFile
 * from database.  Dispose of this with edwFileFree(). */
{
struct edwFile *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->submitId = sqlUnsigned(row[1]);
ret->submitDirId = sqlUnsigned(row[2]);
ret->submitFileName = cloneString(row[3]);
ret->edwFileName = cloneString(row[4]);
ret->startUploadTime = sqlLongLong(row[5]);
ret->endUploadTime = sqlLongLong(row[6]);
ret->updateTime = sqlLongLong(row[7]);
ret->size = sqlLongLong(row[8]);
safecpy(ret->md5, sizeof(ret->md5), row[9]);
ret->tags = cloneString(row[10]);
ret->errorMessage = cloneString(row[11]);
ret->deprecated = cloneString(row[12]);
ret->replacedBy = sqlUnsigned(row[13]);
return ret;
}

struct edwFile *edwFileLoadAll(char *fileName) 
/* Load all edwFile from a whitespace-separated file.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[14];

while (lineFileRow(lf, row))
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwFile *edwFileLoadAllByChar(char *fileName, char chopper) 
/* Load all edwFile from a chopper separated file.
 * Dispose of this with edwFileFreeList(). */
{
struct edwFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[14];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwFile *edwFileCommaIn(char **pS, struct edwFile *ret)
/* Create a edwFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwFile */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->submitId = sqlUnsignedComma(&s);
ret->submitDirId = sqlUnsignedComma(&s);
ret->submitFileName = sqlStringComma(&s);
ret->edwFileName = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->updateTime = sqlLongLongComma(&s);
ret->size = sqlLongLongComma(&s);
sqlFixedStringComma(&s, ret->md5, sizeof(ret->md5));
ret->tags = sqlStringComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->deprecated = sqlStringComma(&s);
ret->replacedBy = sqlUnsignedComma(&s);
*pS = s;
return ret;
}

void edwFileFree(struct edwFile **pEl)
/* Free a single dynamically allocated edwFile such as created
 * with edwFileLoad(). */
{
struct edwFile *el;

if ((el = *pEl) == NULL) return;
freeMem(el->submitFileName);
freeMem(el->edwFileName);
freeMem(el->tags);
freeMem(el->errorMessage);
freeMem(el->deprecated);
freez(pEl);
}

void edwFileFreeList(struct edwFile **pList)
/* Free a list of dynamically allocated edwFile's */
{
struct edwFile *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwFileFree(&el);
    }
*pList = NULL;
}

void edwFileOutput(struct edwFile *el, FILE *f, char sep, char lastSep) 
/* Print out edwFile.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->submitId);
fputc(sep,f);
fprintf(f, "%u", el->submitDirId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->submitFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->edwFileName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->updateTime);
fputc(sep,f);
fprintf(f, "%lld", el->size);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->md5);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tags);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->deprecated);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->replacedBy);
fputc(lastSep,f);
}


char *edwSubmitCommaSepFieldNames = "id,url,startUploadTime,endUploadTime,userId,submitFileId,submitDirId,fileCount,oldFiles,newFiles,byteCount,oldBytes,newBytes,errorMessage,fileIdInTransit";

void edwSubmitStaticLoad(char **row, struct edwSubmit *ret)
/* Load a row from edwSubmit table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->url = row[1];
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
ret->userId = sqlUnsigned(row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->submitDirId = sqlUnsigned(row[6]);
ret->fileCount = sqlUnsigned(row[7]);
ret->oldFiles = sqlUnsigned(row[8]);
ret->newFiles = sqlUnsigned(row[9]);
ret->byteCount = sqlLongLong(row[10]);
ret->oldBytes = sqlLongLong(row[11]);
ret->newBytes = sqlLongLong(row[12]);
ret->errorMessage = row[13];
ret->fileIdInTransit = sqlUnsigned(row[14]);
}

struct edwSubmit *edwSubmitLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwSubmit from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwSubmitFreeList(). */
{
struct edwSubmit *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwSubmitLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwSubmitSaveToDb(struct sqlConnection *conn, struct edwSubmit *el, char *tableName, int updateSize)
/* Save edwSubmit as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,'%s',%lld,%lld,%u,%u,%u,%u,%u,%u,%lld,%lld,%lld,'%s',%u)", 
	tableName,  el->id,  el->url,  el->startUploadTime,  el->endUploadTime,  el->userId,  el->submitFileId,  el->submitDirId,  el->fileCount,  el->oldFiles,  el->newFiles,  el->byteCount,  el->oldBytes,  el->newBytes,  el->errorMessage,  el->fileIdInTransit);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwSubmit *edwSubmitLoad(char **row)
/* Load a edwSubmit from row fetched with select * from edwSubmit
 * from database.  Dispose of this with edwSubmitFree(). */
{
struct edwSubmit *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->url = cloneString(row[1]);
ret->startUploadTime = sqlLongLong(row[2]);
ret->endUploadTime = sqlLongLong(row[3]);
ret->userId = sqlUnsigned(row[4]);
ret->submitFileId = sqlUnsigned(row[5]);
ret->submitDirId = sqlUnsigned(row[6]);
ret->fileCount = sqlUnsigned(row[7]);
ret->oldFiles = sqlUnsigned(row[8]);
ret->newFiles = sqlUnsigned(row[9]);
ret->byteCount = sqlLongLong(row[10]);
ret->oldBytes = sqlLongLong(row[11]);
ret->newBytes = sqlLongLong(row[12]);
ret->errorMessage = cloneString(row[13]);
ret->fileIdInTransit = sqlUnsigned(row[14]);
return ret;
}

struct edwSubmit *edwSubmitLoadAll(char *fileName) 
/* Load all edwSubmit from a whitespace-separated file.
 * Dispose of this with edwSubmitFreeList(). */
{
struct edwSubmit *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[15];

while (lineFileRow(lf, row))
    {
    el = edwSubmitLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmit *edwSubmitLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmit from a chopper separated file.
 * Dispose of this with edwSubmitFreeList(). */
{
struct edwSubmit *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[15];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmitLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmit *edwSubmitCommaIn(char **pS, struct edwSubmit *ret)
/* Create a edwSubmit out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmit */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->url = sqlStringComma(&s);
ret->startUploadTime = sqlLongLongComma(&s);
ret->endUploadTime = sqlLongLongComma(&s);
ret->userId = sqlUnsignedComma(&s);
ret->submitFileId = sqlUnsignedComma(&s);
ret->submitDirId = sqlUnsignedComma(&s);
ret->fileCount = sqlUnsignedComma(&s);
ret->oldFiles = sqlUnsignedComma(&s);
ret->newFiles = sqlUnsignedComma(&s);
ret->byteCount = sqlLongLongComma(&s);
ret->oldBytes = sqlLongLongComma(&s);
ret->newBytes = sqlLongLongComma(&s);
ret->errorMessage = sqlStringComma(&s);
ret->fileIdInTransit = sqlUnsignedComma(&s);
*pS = s;
return ret;
}

void edwSubmitFree(struct edwSubmit **pEl)
/* Free a single dynamically allocated edwSubmit such as created
 * with edwSubmitLoad(). */
{
struct edwSubmit *el;

if ((el = *pEl) == NULL) return;
freeMem(el->url);
freeMem(el->errorMessage);
freez(pEl);
}

void edwSubmitFreeList(struct edwSubmit **pList)
/* Free a list of dynamically allocated edwSubmit's */
{
struct edwSubmit *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmitFree(&el);
    }
*pList = NULL;
}

void edwSubmitOutput(struct edwSubmit *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmit.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->url);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startUploadTime);
fputc(sep,f);
fprintf(f, "%lld", el->endUploadTime);
fputc(sep,f);
fprintf(f, "%u", el->userId);
fputc(sep,f);
fprintf(f, "%u", el->submitFileId);
fputc(sep,f);
fprintf(f, "%u", el->submitDirId);
fputc(sep,f);
fprintf(f, "%u", el->fileCount);
fputc(sep,f);
fprintf(f, "%u", el->oldFiles);
fputc(sep,f);
fprintf(f, "%u", el->newFiles);
fputc(sep,f);
fprintf(f, "%lld", el->byteCount);
fputc(sep,f);
fprintf(f, "%lld", el->oldBytes);
fputc(sep,f);
fprintf(f, "%lld", el->newBytes);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->errorMessage);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->fileIdInTransit);
fputc(lastSep,f);
}


char *edwSubscriberCommaSepFieldNames = "id,name,runOrder,filePattern,dirPattern,tagPattern,onFileEndUpload";

void edwSubscriberStaticLoad(char **row, struct edwSubscriber *ret)
/* Load a row from edwSubscriber table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->runOrder = sqlDouble(row[2]);
ret->filePattern = row[3];
ret->dirPattern = row[4];
ret->tagPattern = row[5];
ret->onFileEndUpload = row[6];
}

struct edwSubscriber *edwSubscriberLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwSubscriber from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwSubscriberFreeList(). */
{
struct edwSubscriber *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwSubscriberLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwSubscriberSaveToDb(struct sqlConnection *conn, struct edwSubscriber *el, char *tableName, int updateSize)
/* Save edwSubscriber as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,'%s',%g,'%s','%s','%s','%s')", 
	tableName,  el->id,  el->name,  el->runOrder,  el->filePattern,  el->dirPattern,  el->tagPattern,  el->onFileEndUpload);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwSubscriber *edwSubscriberLoad(char **row)
/* Load a edwSubscriber from row fetched with select * from edwSubscriber
 * from database.  Dispose of this with edwSubscriberFree(). */
{
struct edwSubscriber *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->runOrder = sqlDouble(row[2]);
ret->filePattern = cloneString(row[3]);
ret->dirPattern = cloneString(row[4]);
ret->tagPattern = cloneString(row[5]);
ret->onFileEndUpload = cloneString(row[6]);
return ret;
}

struct edwSubscriber *edwSubscriberLoadAll(char *fileName) 
/* Load all edwSubscriber from a whitespace-separated file.
 * Dispose of this with edwSubscriberFreeList(). */
{
struct edwSubscriber *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileRow(lf, row))
    {
    el = edwSubscriberLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubscriber *edwSubscriberLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubscriber from a chopper separated file.
 * Dispose of this with edwSubscriberFreeList(). */
{
struct edwSubscriber *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubscriberLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubscriber *edwSubscriberCommaIn(char **pS, struct edwSubscriber *ret)
/* Create a edwSubscriber out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubscriber */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->runOrder = sqlDoubleComma(&s);
ret->filePattern = sqlStringComma(&s);
ret->dirPattern = sqlStringComma(&s);
ret->tagPattern = sqlStringComma(&s);
ret->onFileEndUpload = sqlStringComma(&s);
*pS = s;
return ret;
}

void edwSubscriberFree(struct edwSubscriber **pEl)
/* Free a single dynamically allocated edwSubscriber such as created
 * with edwSubscriberLoad(). */
{
struct edwSubscriber *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->filePattern);
freeMem(el->dirPattern);
freeMem(el->tagPattern);
freeMem(el->onFileEndUpload);
freez(pEl);
}

void edwSubscriberFreeList(struct edwSubscriber **pList)
/* Free a list of dynamically allocated edwSubscriber's */
{
struct edwSubscriber *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubscriberFree(&el);
    }
*pList = NULL;
}

void edwSubscriberOutput(struct edwSubscriber *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubscriber.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%g", el->runOrder);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->filePattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dirPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->tagPattern);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->onFileEndUpload);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}


char *edwAssemblyCommaSepFieldNames = "id,taxon,name,ucscDb,twoBitId,baseCount,realBaseCount";

void edwAssemblyStaticLoad(char **row, struct edwAssembly *ret)
/* Load a row from edwAssembly table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->taxon = sqlUnsigned(row[1]);
ret->name = row[2];
ret->ucscDb = row[3];
ret->twoBitId = sqlUnsigned(row[4]);
ret->baseCount = sqlLongLong(row[5]);
ret->realBaseCount = sqlLongLong(row[6]);
}

struct edwAssembly *edwAssemblyLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwAssembly from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwAssemblyFreeList(). */
{
struct edwAssembly *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwAssemblyLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwAssemblySaveToDb(struct sqlConnection *conn, struct edwAssembly *el, char *tableName, int updateSize)
/* Save edwAssembly as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,%u,'%s','%s',%u,%lld,%lld)", 
	tableName,  el->id,  el->taxon,  el->name,  el->ucscDb,  el->twoBitId,  el->baseCount,  el->realBaseCount);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwAssembly *edwAssemblyLoad(char **row)
/* Load a edwAssembly from row fetched with select * from edwAssembly
 * from database.  Dispose of this with edwAssemblyFree(). */
{
struct edwAssembly *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->taxon = sqlUnsigned(row[1]);
ret->name = cloneString(row[2]);
ret->ucscDb = cloneString(row[3]);
ret->twoBitId = sqlUnsigned(row[4]);
ret->baseCount = sqlLongLong(row[5]);
ret->realBaseCount = sqlLongLong(row[6]);
return ret;
}

struct edwAssembly *edwAssemblyLoadAll(char *fileName) 
/* Load all edwAssembly from a whitespace-separated file.
 * Dispose of this with edwAssemblyFreeList(). */
{
struct edwAssembly *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileRow(lf, row))
    {
    el = edwAssemblyLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwAssembly *edwAssemblyLoadAllByChar(char *fileName, char chopper) 
/* Load all edwAssembly from a chopper separated file.
 * Dispose of this with edwAssemblyFreeList(). */
{
struct edwAssembly *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwAssemblyLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwAssembly *edwAssemblyCommaIn(char **pS, struct edwAssembly *ret)
/* Create a edwAssembly out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwAssembly */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->taxon = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->ucscDb = sqlStringComma(&s);
ret->twoBitId = sqlUnsignedComma(&s);
ret->baseCount = sqlLongLongComma(&s);
ret->realBaseCount = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwAssemblyFree(struct edwAssembly **pEl)
/* Free a single dynamically allocated edwAssembly such as created
 * with edwAssemblyLoad(). */
{
struct edwAssembly *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->ucscDb);
freez(pEl);
}

void edwAssemblyFreeList(struct edwAssembly **pList)
/* Free a list of dynamically allocated edwAssembly's */
{
struct edwAssembly *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwAssemblyFree(&el);
    }
*pList = NULL;
}

void edwAssemblyOutput(struct edwAssembly *el, FILE *f, char sep, char lastSep) 
/* Print out edwAssembly.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->taxon);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->ucscDb);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->twoBitId);
fputc(sep,f);
fprintf(f, "%lld", el->baseCount);
fputc(sep,f);
fprintf(f, "%lld", el->realBaseCount);
fputc(lastSep,f);
}


char *edwValidFileCommaSepFieldNames = "id,licensePlate,fileId,format,outputType,experiment,replicate,validKey,enrichedIn,ucscDb,itemCount,basesInItems,sampleCount,basesInSample,sampleBed,mapRatio,sampleCoverage,depth";

void edwValidFileStaticLoad(char **row, struct edwValidFile *ret)
/* Load a row from edwValidFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->fileId = sqlUnsigned(row[2]);
ret->format = row[3];
ret->outputType = row[4];
ret->experiment = row[5];
ret->replicate = row[6];
ret->validKey = row[7];
ret->enrichedIn = row[8];
ret->ucscDb = row[9];
ret->itemCount = sqlLongLong(row[10]);
ret->basesInItems = sqlLongLong(row[11]);
ret->sampleCount = sqlLongLong(row[12]);
ret->basesInSample = sqlLongLong(row[13]);
ret->sampleBed = row[14];
ret->mapRatio = sqlDouble(row[15]);
ret->sampleCoverage = sqlDouble(row[16]);
ret->depth = sqlDouble(row[17]);
}

struct edwValidFile *edwValidFileLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwValidFile from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwValidFileFreeList(). */
{
struct edwValidFile *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwValidFileLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwValidFileSaveToDb(struct sqlConnection *conn, struct edwValidFile *el, char *tableName, int updateSize)
/* Save edwValidFile as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,'%s',%u,'%s','%s','%s','%s','%s','%s','%s',%lld,%lld,%lld,%lld,'%s',%g,%g,%g)", 
	tableName,  el->id,  el->licensePlate,  el->fileId,  el->format,  el->outputType,  el->experiment,  el->replicate,  el->validKey,  el->enrichedIn,  el->ucscDb,  el->itemCount,  el->basesInItems,  el->sampleCount,  el->basesInSample,  el->sampleBed,  el->mapRatio,  el->sampleCoverage,  el->depth);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwValidFile *edwValidFileLoad(char **row)
/* Load a edwValidFile from row fetched with select * from edwValidFile
 * from database.  Dispose of this with edwValidFileFree(). */
{
struct edwValidFile *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
safecpy(ret->licensePlate, sizeof(ret->licensePlate), row[1]);
ret->fileId = sqlUnsigned(row[2]);
ret->format = cloneString(row[3]);
ret->outputType = cloneString(row[4]);
ret->experiment = cloneString(row[5]);
ret->replicate = cloneString(row[6]);
ret->validKey = cloneString(row[7]);
ret->enrichedIn = cloneString(row[8]);
ret->ucscDb = cloneString(row[9]);
ret->itemCount = sqlLongLong(row[10]);
ret->basesInItems = sqlLongLong(row[11]);
ret->sampleCount = sqlLongLong(row[12]);
ret->basesInSample = sqlLongLong(row[13]);
ret->sampleBed = cloneString(row[14]);
ret->mapRatio = sqlDouble(row[15]);
ret->sampleCoverage = sqlDouble(row[16]);
ret->depth = sqlDouble(row[17]);
return ret;
}

struct edwValidFile *edwValidFileLoadAll(char *fileName) 
/* Load all edwValidFile from a whitespace-separated file.
 * Dispose of this with edwValidFileFreeList(). */
{
struct edwValidFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[18];

while (lineFileRow(lf, row))
    {
    el = edwValidFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwValidFile *edwValidFileLoadAllByChar(char *fileName, char chopper) 
/* Load all edwValidFile from a chopper separated file.
 * Dispose of this with edwValidFileFreeList(). */
{
struct edwValidFile *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[18];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwValidFileLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwValidFile *edwValidFileCommaIn(char **pS, struct edwValidFile *ret)
/* Create a edwValidFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwValidFile */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
sqlFixedStringComma(&s, ret->licensePlate, sizeof(ret->licensePlate));
ret->fileId = sqlUnsignedComma(&s);
ret->format = sqlStringComma(&s);
ret->outputType = sqlStringComma(&s);
ret->experiment = sqlStringComma(&s);
ret->replicate = sqlStringComma(&s);
ret->validKey = sqlStringComma(&s);
ret->enrichedIn = sqlStringComma(&s);
ret->ucscDb = sqlStringComma(&s);
ret->itemCount = sqlLongLongComma(&s);
ret->basesInItems = sqlLongLongComma(&s);
ret->sampleCount = sqlLongLongComma(&s);
ret->basesInSample = sqlLongLongComma(&s);
ret->sampleBed = sqlStringComma(&s);
ret->mapRatio = sqlDoubleComma(&s);
ret->sampleCoverage = sqlDoubleComma(&s);
ret->depth = sqlDoubleComma(&s);
*pS = s;
return ret;
}

void edwValidFileFree(struct edwValidFile **pEl)
/* Free a single dynamically allocated edwValidFile such as created
 * with edwValidFileLoad(). */
{
struct edwValidFile *el;

if ((el = *pEl) == NULL) return;
freeMem(el->format);
freeMem(el->outputType);
freeMem(el->experiment);
freeMem(el->replicate);
freeMem(el->validKey);
freeMem(el->enrichedIn);
freeMem(el->ucscDb);
freeMem(el->sampleBed);
freez(pEl);
}

void edwValidFileFreeList(struct edwValidFile **pList)
/* Free a list of dynamically allocated edwValidFile's */
{
struct edwValidFile *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwValidFileFree(&el);
    }
*pList = NULL;
}

void edwValidFileOutput(struct edwValidFile *el, FILE *f, char sep, char lastSep) 
/* Print out edwValidFile.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->licensePlate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->fileId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->format);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->outputType);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->experiment);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->replicate);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->validKey);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->enrichedIn);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->ucscDb);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->itemCount);
fputc(sep,f);
fprintf(f, "%lld", el->basesInItems);
fputc(sep,f);
fprintf(f, "%lld", el->sampleCount);
fputc(sep,f);
fprintf(f, "%lld", el->basesInSample);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->sampleBed);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%g", el->mapRatio);
fputc(sep,f);
fprintf(f, "%g", el->sampleCoverage);
fputc(sep,f);
fprintf(f, "%g", el->depth);
fputc(lastSep,f);
}


char *edwQaEnrichTargetCommaSepFieldNames = "id,assemblyId,name,fileId,targetSize";

void edwQaEnrichTargetStaticLoad(char **row, struct edwQaEnrichTarget *ret)
/* Load a row from edwQaEnrichTarget table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->assemblyId = sqlUnsigned(row[1]);
ret->name = row[2];
ret->fileId = sqlUnsigned(row[3]);
ret->targetSize = sqlLongLong(row[4]);
}

struct edwQaEnrichTarget *edwQaEnrichTargetLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwQaEnrichTarget from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwQaEnrichTargetFreeList(). */
{
struct edwQaEnrichTarget *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwQaEnrichTargetLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwQaEnrichTargetSaveToDb(struct sqlConnection *conn, struct edwQaEnrichTarget *el, char *tableName, int updateSize)
/* Save edwQaEnrichTarget as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,%u,'%s',%u,%lld)", 
	tableName,  el->id,  el->assemblyId,  el->name,  el->fileId,  el->targetSize);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwQaEnrichTarget *edwQaEnrichTargetLoad(char **row)
/* Load a edwQaEnrichTarget from row fetched with select * from edwQaEnrichTarget
 * from database.  Dispose of this with edwQaEnrichTargetFree(). */
{
struct edwQaEnrichTarget *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->assemblyId = sqlUnsigned(row[1]);
ret->name = cloneString(row[2]);
ret->fileId = sqlUnsigned(row[3]);
ret->targetSize = sqlLongLong(row[4]);
return ret;
}

struct edwQaEnrichTarget *edwQaEnrichTargetLoadAll(char *fileName) 
/* Load all edwQaEnrichTarget from a whitespace-separated file.
 * Dispose of this with edwQaEnrichTargetFreeList(). */
{
struct edwQaEnrichTarget *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileRow(lf, row))
    {
    el = edwQaEnrichTargetLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaEnrichTarget *edwQaEnrichTargetLoadAllByChar(char *fileName, char chopper) 
/* Load all edwQaEnrichTarget from a chopper separated file.
 * Dispose of this with edwQaEnrichTargetFreeList(). */
{
struct edwQaEnrichTarget *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwQaEnrichTargetLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaEnrichTarget *edwQaEnrichTargetCommaIn(char **pS, struct edwQaEnrichTarget *ret)
/* Create a edwQaEnrichTarget out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaEnrichTarget */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->assemblyId = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->fileId = sqlUnsignedComma(&s);
ret->targetSize = sqlLongLongComma(&s);
*pS = s;
return ret;
}

void edwQaEnrichTargetFree(struct edwQaEnrichTarget **pEl)
/* Free a single dynamically allocated edwQaEnrichTarget such as created
 * with edwQaEnrichTargetLoad(). */
{
struct edwQaEnrichTarget *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freez(pEl);
}

void edwQaEnrichTargetFreeList(struct edwQaEnrichTarget **pList)
/* Free a list of dynamically allocated edwQaEnrichTarget's */
{
struct edwQaEnrichTarget *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwQaEnrichTargetFree(&el);
    }
*pList = NULL;
}

void edwQaEnrichTargetOutput(struct edwQaEnrichTarget *el, FILE *f, char sep, char lastSep) 
/* Print out edwQaEnrichTarget.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->assemblyId);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->fileId);
fputc(sep,f);
fprintf(f, "%lld", el->targetSize);
fputc(lastSep,f);
}


char *edwQaEnrichCommaSepFieldNames = "id,fileId,qaEnrichTargetId,targetBaseHits,targetUniqHits,coverage,enrichment,uniqEnrich";

void edwQaEnrichStaticLoad(char **row, struct edwQaEnrich *ret)
/* Load a row from edwQaEnrich table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->fileId = sqlUnsigned(row[1]);
ret->qaEnrichTargetId = sqlUnsigned(row[2]);
ret->targetBaseHits = sqlLongLong(row[3]);
ret->targetUniqHits = sqlLongLong(row[4]);
ret->coverage = sqlDouble(row[5]);
ret->enrichment = sqlDouble(row[6]);
ret->uniqEnrich = sqlDouble(row[7]);
}

struct edwQaEnrich *edwQaEnrichLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwQaEnrich from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwQaEnrichFreeList(). */
{
struct edwQaEnrich *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwQaEnrichLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwQaEnrichSaveToDb(struct sqlConnection *conn, struct edwQaEnrich *el, char *tableName, int updateSize)
/* Save edwQaEnrich as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,%u,%u,%lld,%lld,%g,%g,%g)", 
	tableName,  el->id,  el->fileId,  el->qaEnrichTargetId,  el->targetBaseHits,  el->targetUniqHits,  el->coverage,  el->enrichment,  el->uniqEnrich);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwQaEnrich *edwQaEnrichLoad(char **row)
/* Load a edwQaEnrich from row fetched with select * from edwQaEnrich
 * from database.  Dispose of this with edwQaEnrichFree(). */
{
struct edwQaEnrich *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->fileId = sqlUnsigned(row[1]);
ret->qaEnrichTargetId = sqlUnsigned(row[2]);
ret->targetBaseHits = sqlLongLong(row[3]);
ret->targetUniqHits = sqlLongLong(row[4]);
ret->coverage = sqlDouble(row[5]);
ret->enrichment = sqlDouble(row[6]);
ret->uniqEnrich = sqlDouble(row[7]);
return ret;
}

struct edwQaEnrich *edwQaEnrichLoadAll(char *fileName) 
/* Load all edwQaEnrich from a whitespace-separated file.
 * Dispose of this with edwQaEnrichFreeList(). */
{
struct edwQaEnrich *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileRow(lf, row))
    {
    el = edwQaEnrichLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaEnrich *edwQaEnrichLoadAllByChar(char *fileName, char chopper) 
/* Load all edwQaEnrich from a chopper separated file.
 * Dispose of this with edwQaEnrichFreeList(). */
{
struct edwQaEnrich *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[8];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwQaEnrichLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaEnrich *edwQaEnrichCommaIn(char **pS, struct edwQaEnrich *ret)
/* Create a edwQaEnrich out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaEnrich */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->fileId = sqlUnsignedComma(&s);
ret->qaEnrichTargetId = sqlUnsignedComma(&s);
ret->targetBaseHits = sqlLongLongComma(&s);
ret->targetUniqHits = sqlLongLongComma(&s);
ret->coverage = sqlDoubleComma(&s);
ret->enrichment = sqlDoubleComma(&s);
ret->uniqEnrich = sqlDoubleComma(&s);
*pS = s;
return ret;
}

void edwQaEnrichFree(struct edwQaEnrich **pEl)
/* Free a single dynamically allocated edwQaEnrich such as created
 * with edwQaEnrichLoad(). */
{
struct edwQaEnrich *el;

if ((el = *pEl) == NULL) return;
freez(pEl);
}

void edwQaEnrichFreeList(struct edwQaEnrich **pList)
/* Free a list of dynamically allocated edwQaEnrich's */
{
struct edwQaEnrich *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwQaEnrichFree(&el);
    }
*pList = NULL;
}

void edwQaEnrichOutput(struct edwQaEnrich *el, FILE *f, char sep, char lastSep) 
/* Print out edwQaEnrich.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->fileId);
fputc(sep,f);
fprintf(f, "%u", el->qaEnrichTargetId);
fputc(sep,f);
fprintf(f, "%lld", el->targetBaseHits);
fputc(sep,f);
fprintf(f, "%lld", el->targetUniqHits);
fputc(sep,f);
fprintf(f, "%g", el->coverage);
fputc(sep,f);
fprintf(f, "%g", el->enrichment);
fputc(sep,f);
fprintf(f, "%g", el->uniqEnrich);
fputc(lastSep,f);
}


char *edwQaPairSampleOverlapCommaSepFieldNames = "id,elderFileId,youngerFileId,elderSampleBases,youngerSampleBases,sampleOverlapBases,sampleSampleEnrichment";

void edwQaPairSampleOverlapStaticLoad(char **row, struct edwQaPairSampleOverlap *ret)
/* Load a row from edwQaPairSampleOverlap table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->elderFileId = sqlUnsigned(row[1]);
ret->youngerFileId = sqlUnsigned(row[2]);
ret->elderSampleBases = sqlLongLong(row[3]);
ret->youngerSampleBases = sqlLongLong(row[4]);
ret->sampleOverlapBases = sqlLongLong(row[5]);
ret->sampleSampleEnrichment = sqlDouble(row[6]);
}

struct edwQaPairSampleOverlap *edwQaPairSampleOverlapLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwQaPairSampleOverlap from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwQaPairSampleOverlapFreeList(). */
{
struct edwQaPairSampleOverlap *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwQaPairSampleOverlapLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwQaPairSampleOverlapSaveToDb(struct sqlConnection *conn, struct edwQaPairSampleOverlap *el, char *tableName, int updateSize)
/* Save edwQaPairSampleOverlap as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,%u,%u,%lld,%lld,%lld,%g)", 
	tableName,  el->id,  el->elderFileId,  el->youngerFileId,  el->elderSampleBases,  el->youngerSampleBases,  el->sampleOverlapBases,  el->sampleSampleEnrichment);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwQaPairSampleOverlap *edwQaPairSampleOverlapLoad(char **row)
/* Load a edwQaPairSampleOverlap from row fetched with select * from edwQaPairSampleOverlap
 * from database.  Dispose of this with edwQaPairSampleOverlapFree(). */
{
struct edwQaPairSampleOverlap *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->elderFileId = sqlUnsigned(row[1]);
ret->youngerFileId = sqlUnsigned(row[2]);
ret->elderSampleBases = sqlLongLong(row[3]);
ret->youngerSampleBases = sqlLongLong(row[4]);
ret->sampleOverlapBases = sqlLongLong(row[5]);
ret->sampleSampleEnrichment = sqlDouble(row[6]);
return ret;
}

struct edwQaPairSampleOverlap *edwQaPairSampleOverlapLoadAll(char *fileName) 
/* Load all edwQaPairSampleOverlap from a whitespace-separated file.
 * Dispose of this with edwQaPairSampleOverlapFreeList(). */
{
struct edwQaPairSampleOverlap *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileRow(lf, row))
    {
    el = edwQaPairSampleOverlapLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaPairSampleOverlap *edwQaPairSampleOverlapLoadAllByChar(char *fileName, char chopper) 
/* Load all edwQaPairSampleOverlap from a chopper separated file.
 * Dispose of this with edwQaPairSampleOverlapFreeList(). */
{
struct edwQaPairSampleOverlap *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwQaPairSampleOverlapLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaPairSampleOverlap *edwQaPairSampleOverlapCommaIn(char **pS, struct edwQaPairSampleOverlap *ret)
/* Create a edwQaPairSampleOverlap out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaPairSampleOverlap */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->elderFileId = sqlUnsignedComma(&s);
ret->youngerFileId = sqlUnsignedComma(&s);
ret->elderSampleBases = sqlLongLongComma(&s);
ret->youngerSampleBases = sqlLongLongComma(&s);
ret->sampleOverlapBases = sqlLongLongComma(&s);
ret->sampleSampleEnrichment = sqlDoubleComma(&s);
*pS = s;
return ret;
}

void edwQaPairSampleOverlapFree(struct edwQaPairSampleOverlap **pEl)
/* Free a single dynamically allocated edwQaPairSampleOverlap such as created
 * with edwQaPairSampleOverlapLoad(). */
{
struct edwQaPairSampleOverlap *el;

if ((el = *pEl) == NULL) return;
freez(pEl);
}

void edwQaPairSampleOverlapFreeList(struct edwQaPairSampleOverlap **pList)
/* Free a list of dynamically allocated edwQaPairSampleOverlap's */
{
struct edwQaPairSampleOverlap *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwQaPairSampleOverlapFree(&el);
    }
*pList = NULL;
}

void edwQaPairSampleOverlapOutput(struct edwQaPairSampleOverlap *el, FILE *f, char sep, char lastSep) 
/* Print out edwQaPairSampleOverlap.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->elderFileId);
fputc(sep,f);
fprintf(f, "%u", el->youngerFileId);
fputc(sep,f);
fprintf(f, "%lld", el->elderSampleBases);
fputc(sep,f);
fprintf(f, "%lld", el->youngerSampleBases);
fputc(sep,f);
fprintf(f, "%lld", el->sampleOverlapBases);
fputc(sep,f);
fprintf(f, "%g", el->sampleSampleEnrichment);
fputc(lastSep,f);
}


char *edwQaPairCorrelationCommaSepFieldNames = "id,elderFileId,youngerFileId,pearsonInEnriched,pearsonOverall,pearsonClipped";

void edwQaPairCorrelationStaticLoad(char **row, struct edwQaPairCorrelation *ret)
/* Load a row from edwQaPairCorrelation table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->elderFileId = sqlUnsigned(row[1]);
ret->youngerFileId = sqlUnsigned(row[2]);
ret->pearsonInEnriched = sqlDouble(row[3]);
ret->pearsonOverall = sqlDouble(row[4]);
ret->pearsonClipped = sqlDouble(row[5]);
}

struct edwQaPairCorrelation *edwQaPairCorrelationLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwQaPairCorrelation from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwQaPairCorrelationFreeList(). */
{
struct edwQaPairCorrelation *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwQaPairCorrelationLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwQaPairCorrelationSaveToDb(struct sqlConnection *conn, struct edwQaPairCorrelation *el, char *tableName, int updateSize)
/* Save edwQaPairCorrelation as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,%u,%u,%g,%g,%g)", 
	tableName,  el->id,  el->elderFileId,  el->youngerFileId,  el->pearsonInEnriched,  el->pearsonOverall,  el->pearsonClipped);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwQaPairCorrelation *edwQaPairCorrelationLoad(char **row)
/* Load a edwQaPairCorrelation from row fetched with select * from edwQaPairCorrelation
 * from database.  Dispose of this with edwQaPairCorrelationFree(). */
{
struct edwQaPairCorrelation *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->elderFileId = sqlUnsigned(row[1]);
ret->youngerFileId = sqlUnsigned(row[2]);
ret->pearsonInEnriched = sqlDouble(row[3]);
ret->pearsonOverall = sqlDouble(row[4]);
ret->pearsonClipped = sqlDouble(row[5]);
return ret;
}

struct edwQaPairCorrelation *edwQaPairCorrelationLoadAll(char *fileName) 
/* Load all edwQaPairCorrelation from a whitespace-separated file.
 * Dispose of this with edwQaPairCorrelationFreeList(). */
{
struct edwQaPairCorrelation *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = edwQaPairCorrelationLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaPairCorrelation *edwQaPairCorrelationLoadAllByChar(char *fileName, char chopper) 
/* Load all edwQaPairCorrelation from a chopper separated file.
 * Dispose of this with edwQaPairCorrelationFreeList(). */
{
struct edwQaPairCorrelation *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwQaPairCorrelationLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwQaPairCorrelation *edwQaPairCorrelationCommaIn(char **pS, struct edwQaPairCorrelation *ret)
/* Create a edwQaPairCorrelation out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaPairCorrelation */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->elderFileId = sqlUnsignedComma(&s);
ret->youngerFileId = sqlUnsignedComma(&s);
ret->pearsonInEnriched = sqlDoubleComma(&s);
ret->pearsonOverall = sqlDoubleComma(&s);
ret->pearsonClipped = sqlDoubleComma(&s);
*pS = s;
return ret;
}

void edwQaPairCorrelationFree(struct edwQaPairCorrelation **pEl)
/* Free a single dynamically allocated edwQaPairCorrelation such as created
 * with edwQaPairCorrelationLoad(). */
{
struct edwQaPairCorrelation *el;

if ((el = *pEl) == NULL) return;
freez(pEl);
}

void edwQaPairCorrelationFreeList(struct edwQaPairCorrelation **pList)
/* Free a list of dynamically allocated edwQaPairCorrelation's */
{
struct edwQaPairCorrelation *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwQaPairCorrelationFree(&el);
    }
*pList = NULL;
}

void edwQaPairCorrelationOutput(struct edwQaPairCorrelation *el, FILE *f, char sep, char lastSep) 
/* Print out edwQaPairCorrelation.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->elderFileId);
fputc(sep,f);
fprintf(f, "%u", el->youngerFileId);
fputc(sep,f);
fprintf(f, "%g", el->pearsonInEnriched);
fputc(sep,f);
fprintf(f, "%g", el->pearsonOverall);
fputc(sep,f);
fprintf(f, "%g", el->pearsonClipped);
fputc(lastSep,f);
}


char *edwJobCommaSepFieldNames = "id,commandLine,startTime,endTime,stderr,returnCode";

void edwJobStaticLoad(char **row, struct edwJob *ret)
/* Load a row from edwJob table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->commandLine = row[1];
ret->startTime = sqlLongLong(row[2]);
ret->endTime = sqlLongLong(row[3]);
ret->stderr = row[4];
ret->returnCode = sqlSigned(row[5]);
}

struct edwJob *edwJobLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwJob from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwJobFreeList(). */
{
struct edwJob *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwJobLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwJobSaveToDb(struct sqlConnection *conn, struct edwJob *el, char *tableName, int updateSize)
/* Save edwJob as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,'%s',%lld,%lld,'%s',%d)", 
	tableName,  el->id,  el->commandLine,  el->startTime,  el->endTime,  el->stderr,  el->returnCode);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwJob *edwJobLoad(char **row)
/* Load a edwJob from row fetched with select * from edwJob
 * from database.  Dispose of this with edwJobFree(). */
{
struct edwJob *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->commandLine = cloneString(row[1]);
ret->startTime = sqlLongLong(row[2]);
ret->endTime = sqlLongLong(row[3]);
ret->stderr = cloneString(row[4]);
ret->returnCode = sqlSigned(row[5]);
return ret;
}

struct edwJob *edwJobLoadAll(char *fileName) 
/* Load all edwJob from a whitespace-separated file.
 * Dispose of this with edwJobFreeList(). */
{
struct edwJob *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = edwJobLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwJob *edwJobLoadAllByChar(char *fileName, char chopper) 
/* Load all edwJob from a chopper separated file.
 * Dispose of this with edwJobFreeList(). */
{
struct edwJob *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwJobLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwJob *edwJobCommaIn(char **pS, struct edwJob *ret)
/* Create a edwJob out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwJob */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->commandLine = sqlStringComma(&s);
ret->startTime = sqlLongLongComma(&s);
ret->endTime = sqlLongLongComma(&s);
ret->stderr = sqlStringComma(&s);
ret->returnCode = sqlSignedComma(&s);
*pS = s;
return ret;
}

void edwJobFree(struct edwJob **pEl)
/* Free a single dynamically allocated edwJob such as created
 * with edwJobLoad(). */
{
struct edwJob *el;

if ((el = *pEl) == NULL) return;
freeMem(el->commandLine);
freeMem(el->stderr);
freez(pEl);
}

void edwJobFreeList(struct edwJob **pList)
/* Free a list of dynamically allocated edwJob's */
{
struct edwJob *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwJobFree(&el);
    }
*pList = NULL;
}

void edwJobOutput(struct edwJob *el, FILE *f, char sep, char lastSep) 
/* Print out edwJob.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->commandLine);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startTime);
fputc(sep,f);
fprintf(f, "%lld", el->endTime);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->stderr);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%d", el->returnCode);
fputc(lastSep,f);
}


char *edwSubmitJobCommaSepFieldNames = "id,commandLine,startTime,endTime,stderr,returnCode";

void edwSubmitJobStaticLoad(char **row, struct edwSubmitJob *ret)
/* Load a row from edwSubmitJob table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->commandLine = row[1];
ret->startTime = sqlLongLong(row[2]);
ret->endTime = sqlLongLong(row[3]);
ret->stderr = row[4];
ret->returnCode = sqlSigned(row[5]);
}

struct edwSubmitJob *edwSubmitJobLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all edwSubmitJob from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwSubmitJobFreeList(). */
{
struct edwSubmitJob *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = edwSubmitJobLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void edwSubmitJobSaveToDb(struct sqlConnection *conn, struct edwSubmitJob *el, char *tableName, int updateSize)
/* Save edwSubmitJob as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Strings are automatically escaped to allow insertion into the database. */
{
struct dyString *update = newDyString(updateSize);
sqlDyStringPrintf(update, "insert into %s values ( %u,'%s',%lld,%lld,'%s',%d)", 
	tableName,  el->id,  el->commandLine,  el->startTime,  el->endTime,  el->stderr,  el->returnCode);
sqlUpdate(conn, update->string);
freeDyString(&update);
}


struct edwSubmitJob *edwSubmitJobLoad(char **row)
/* Load a edwSubmitJob from row fetched with select * from edwSubmitJob
 * from database.  Dispose of this with edwSubmitJobFree(). */
{
struct edwSubmitJob *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->commandLine = cloneString(row[1]);
ret->startTime = sqlLongLong(row[2]);
ret->endTime = sqlLongLong(row[3]);
ret->stderr = cloneString(row[4]);
ret->returnCode = sqlSigned(row[5]);
return ret;
}

struct edwSubmitJob *edwSubmitJobLoadAll(char *fileName) 
/* Load all edwSubmitJob from a whitespace-separated file.
 * Dispose of this with edwSubmitJobFreeList(). */
{
struct edwSubmitJob *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileRow(lf, row))
    {
    el = edwSubmitJobLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmitJob *edwSubmitJobLoadAllByChar(char *fileName, char chopper) 
/* Load all edwSubmitJob from a chopper separated file.
 * Dispose of this with edwSubmitJobFreeList(). */
{
struct edwSubmitJob *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[6];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = edwSubmitJobLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct edwSubmitJob *edwSubmitJobCommaIn(char **pS, struct edwSubmitJob *ret)
/* Create a edwSubmitJob out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmitJob */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->commandLine = sqlStringComma(&s);
ret->startTime = sqlLongLongComma(&s);
ret->endTime = sqlLongLongComma(&s);
ret->stderr = sqlStringComma(&s);
ret->returnCode = sqlSignedComma(&s);
*pS = s;
return ret;
}

void edwSubmitJobFree(struct edwSubmitJob **pEl)
/* Free a single dynamically allocated edwSubmitJob such as created
 * with edwSubmitJobLoad(). */
{
struct edwSubmitJob *el;

if ((el = *pEl) == NULL) return;
freeMem(el->commandLine);
freeMem(el->stderr);
freez(pEl);
}

void edwSubmitJobFreeList(struct edwSubmitJob **pList)
/* Free a list of dynamically allocated edwSubmitJob's */
{
struct edwSubmitJob *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    edwSubmitJobFree(&el);
    }
*pList = NULL;
}

void edwSubmitJobOutput(struct edwSubmitJob *el, FILE *f, char sep, char lastSep) 
/* Print out edwSubmitJob.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->commandLine);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%lld", el->startTime);
fputc(sep,f);
fprintf(f, "%lld", el->endTime);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->stderr);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%d", el->returnCode);
fputc(lastSep,f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

