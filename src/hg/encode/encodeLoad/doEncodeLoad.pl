#!/usr/bin/env perl

# encodeLoad.pl - load ENCODE data submission generated by the
#                       automated submission pipeline
# Reads load.ra for information about what to do

# Writes error or log information to STDOUT
# Returns 0 if load succeeds.

# DO NOT EDIT the /cluster/bin/scripts copy of this file -- 
# edit the CVS'ed source at:
# ~/kent/src/hg/encode/encodeLoad/doEncodeLoad.pl

# Usage:
# 
# ./doEncodeLoad.pl unused /cluster/data/encode/pipeline/encpipeline_kate/83

use warnings;
use strict;

use File::Temp;
use File::Basename;
use lib "/cluster/bin/scripts";
use RAFile;

my $loadRa = "out/load.ra";
my $unloadRa = "out/unload.ra";
my $submitDir = "";
my $submitType = "";
my $tempDir = "/data/tmp";
my $encodeDb = "hg18";
my $encInstance = "";
my $encProject = "";
my $sqlCreate = "/cluster/bin/sqlCreate";

my $debug = 0;

sub usage
{
    die <<END
usage: doEncodeLoad.rb submission_type project_submission_dir

Assumes existence of a file called: project_submission_dir/$loadRa
END
}

sub dieFile
{
    my ($file) = @_;
    open(FILE, $file);
    die join("", <FILE>);
}

sub loadGene
{
    my ($tableName, $fileList) = @_;

    if(system("cat $fileList | egrep -v '^track|browser' | ldHgGene -genePredExt $encodeDb $tableName stdin > out/loadGene.out 2>&1")) {
        print STDERR "ERROR: File(s) '$fileList' failed gene load.\n";
        dieFile("out/loadGene.out");
    } else {
        print "$fileList Loaded into $tableName\n";
        # debug restore: File.delete "genePred.tab";
    }
}

sub loadWig
{
    my ($tableName, $fileList) = @_;

    if(system( "cat $fileList | wigEncode stdin stdout $tableName.wib | hgLoadWiggle -pathPrefix=/gbdb/$encodeDb/wib -tmpDir=$tempDir $encodeDb $tableName stdin > out/loadWig.out 2>&1") ||
       system( "rm -f /gbdb/$encodeDb/wib/$tableName.wib") ||
       system( "ln -s $tableName.wib /gbdb/$encodeDb/wib")) {
       print STDERR "ERROR: File(s) $fileList failed wiggle load.\n";
       dieFile("out/loadWig.out")
   } else {
       print "$fileList Loaded into $tableName\n";
   }
}

sub loadBed
{
    my ($tableName, $fileList) = @_;
    #TEST by replacing "cat" with  "head -1000 -q"
    my $cmd = "cat $fileList | egrep -v '^track|browser' | hgLoadBed $encodeDb $tableName stdin -tmpDir=out > out/loadBed.out 2>&1";

    print STDERR "loadBed: cmd: $cmd\n";

    if(system($cmd)) {
        print STDERR "ERROR: File(s) $fileList failed bed load.\n";
        dieFile("out/loadBed.out");
    } else {
        print "$fileList Loaded into $tableName\n";
        #debug restore: File.delete "out/bed.tab";
    }
}


sub loadBed5Plus
{
    my ($tableName, $fileList, $sqlTable) = @_;

    if(!(open(SQL, "$sqlCreate/${sqlTable}.sql"))) {
        die "$sqlCreate/${sqlTable}.sql not found; error: $!";
    }

    my $sql = join("", <SQL>);
    if(!($sql =~ s/$sqlTable/$tableName/g)) {
        die "sql names do not match for substitution: $sqlTable $tableName";
    }

    print STDERR "loadBed5Plus: $sql\n" if($debug);

    my ($fh, $tempFile) = File::Temp::tempfile("sqlXXXX", UNLINK => 1);
    print STDERR "tempFile: $tempFile\n" if($debug);
    $fh->print($sql);

    #TEST by replacing "cat" with  "head -1000 -q"
    
    my $cmd = "cat $fileList | egrep -v '^track|browser' | hgLoadBed $encodeDb $tableName stdin -tmpDir=out -sqlTable=$tempFile > out/loadBed.out 2>&1";

    print STDERR "cmd: $cmd\n" if($debug);

    if(system($cmd)) {
        print STDERR "ERROR: File(s) $fileList failed bed load.\n";
        dieFile("out/loadBed.out");
    } else {
        print "$fileList Loaded into $tableName\n";
        #debug restore: File.delete "out/bed.tab"
    }
    $fh->close();
    unlink($tempFile);
    close(SQL);
}


############################################################################
# Main

# Change dir to submission directory obtained from command-line

if(@ARGV != 2) {
    usage();
}

$submitType = $ARGV[0];	# currently not used
$submitDir = $ARGV[1];

$encInstance = dirname($submitDir);
$encProject = basename($submitDir);

# XXXX what is this for?
if($encInstance =~ /(_.*)/) {
    $encInstance = $1;
}

chdir($submitDir);

# clean out any stuff from previous load
# We assume unload program is in the same location as loader (fixes problem with misconfigured qateam environment).

my $programDir = dirname($0);
# XXXX change to "doEncodeUnload.pl" when ready
if(system("$programDir/doEncodeUnload.rb $submitType $submitDir")) {
    die "expected error running $programDir/doEncodeUnload.rb cleanup script";
}

if(!(-e $loadRa)) {
    die "unexpected error: load.ra not found\n";
}

#TODO change to : FileUtils.cp $loadRa, $unloadRa
# XXXX shouldn't we do the cp AFTER we finish everything else successfully?
if(system("cp $loadRa $unloadRa")) {
    die "Cannot: cp $loadRa $unloadRa";
}

print STDERR "Loading project in directory $submitDir\n" if($debug);

# Load files listed in load.ra

my @ra = RAFile::readRaFile($loadRa);

print STDERR "$loadRa has: " . scalar(@ra) . " records\n" if($debug);

print STDERR "\n" if($debug);

for my $ele (@ra) {
    my $h = $ele->{HASH};
    my $tablenameExt = $h->{tablename} . "${encInstance}_$encProject";
    if($debug == 2) {
        print STDERR "keyword: $ele->{KEYWORD}\n";
        for my $field (qw(tablename type tableType assembly files tablenameExt)) {
            if($h->{$field}) {
                print STDERR "$field: " . $h->{$field} . "\n";
            }
        }
        print STDERR "\n";
    }

    # temporary work-around (XXXX, galt why is this "temporary?").

    $encodeDb = $h->{assembly};

    if($h->{type} eq "genePred") {
        loadGene($tablenameExt, $h->{files});
    } elsif ($h->{type} eq "wig") {
        loadWig($tablenameExt, $h->{files});
    } elsif ($h->{type} eq "bed 5 +") {
        loadBed5Plus($tablenameExt, $h->{files}, $h->{tableType});
    } elsif (($h->{type} eq "bed 3") || ($h->{type} eq "bed 4") || ($h->{type} eq "bed 4") || ($h->{type} eq "bed 5") || ($h->{type} eq "bed 6")) {
        loadBed($tablenameExt, $h->{files});
    } else {
        die "ERROR: unknown type: $h->{type} in load.ra\n";
    }
    print STDERR "\n" if($debug);
}

exit(0);
