#!/bin/bash -e
#
# Run blat, polyInfo and pslIntronsOnly.
#
# gbBlat [options] database genomeFile rnaFa out.psl
#
# Options:
#  -keep - keep temporary files.
# Arguments:
#  - database - hg13, etc; used to determine ooc file to use.
#
#  - genomeFile - the contig fasta file or chromosome nib subseq spec.
#
#  - rnaFa - the RNA/EST query fasta file.  The name of this file
#    must be in the form type.orgCat.* (mrna.native, est.aa.xeno, etc).  This
#    is used to determine various parameter settings.  File should be named
#    in the form:
#       ..../refseq.136.0/hg16/full/mrna.xeno.0.fa
#    so refseq.ver or genbank.ver can be used to determine srcDb.
#    
#  - out.psl - PSL output file  The other output filenames are derived
#    by removing the .psl from the name.  If no sequences align, an
#    empty psl is still created to server as a job-completed marker.
#
# PSL files are written to a local tmp directory and then copies to the output
# directory to minimize NFS trafic.  If no sequences align, an empty psl file
# is still produced.  This script is very careful to exit non-zero if an error
# occurs.
#
# $Id: gbBlat,v 1.9 2003/08/19 19:15:40 markd Exp $
#
set -e

# Tools are normally taken from /cluster/bin, however we allow them to be
# overridden by puting them under gbRoot/bin/i386.  Use path to this script to
# find bin dir. Can't use MACHTYPE as it is i686-pc-linux-gnu on the cluster.
gbBin=`dirname $0`/i386
stdBin=/cluster/bin/i386
PATH="$gbBin:$stdBin:$PATH"
export PATH

BLAT=blat
POLYINFO=polyInfo
PSL_INTRONS_ONLY=pslIntronsOnly

HG_OOC=/scratch/hg/h/11.ooc
MM_OOC=/scratch/hg/h/mouse11.ooc
RN_OOC=/scratch/hg/h/rat11.ooc

# entry, parse arguments
keepTmp="NO"
while [[ $1 == -* ]] ; do
    opt="$1"
    shift
    case "$opt" in
        -keep)
            keepTmp="YES";;
        *)
            echo "Error: invalid option: $opt" >&2
            exit 1 ;;
    esac
done

if [ $# -ne 4 ] ; then
    echo 'Wrong # args: gbBlat [options] database genomeFile rnaFa pslBaseDir' >&2
    exit 1
fi
database="$1"
genomeFile="$2"
rnaFa="$3"
rnaBase=`basename $rnaFa .fa`
outPsl="$4"

outDir=`dirname $outPsl`
outBase=`basename $outPsl .psl`
outPrefix=$outDir/$outBase

outOi="$outPrefix.oi"
outIntronPsl="$outPrefix.intronPsl"

# skip if output file already exists
if [ -e $outPsl ] ; then
    echo "output psl exists, skipping: $outPsl" >&2
    exit 0
fi

# Parse input file name for use in selecting parameters.

# get srcDb by looking at the directory names:
dir=`dirname $rnaFa`
dir=`dirname $dir`
dir=`dirname $dir`

case "`basename $dir`" in
    genbank.*)
        srcDb="genbank";;
    refseq.*)
        srcDb="refseq";;
    *) echo "Error: can't determine srcDb from $rnaFa" >&2
        exit 1;;
esac

# get type and orgCat from filename.
set -- `echo $rnaBase |sed 's/\./ /g'`
if [ $# -lt 3 ] ; then
    echo "Error: can't parse mrna file name to get parameters: $rnaBase" >&2
    exit 1
fi
type=$1
# get orgCat, ESTs are split by accPrefix as well
if [ "x$type" = "xest" ] ; then
    orgCat=$3
else
    orgCat=$2
fi
case "$type" in
    mrna|est) ;;
    *) echo "Error: invalid type \"$type\" in mrna file name: $rnaBase" >&2
    exit 1;;
esac
case "$orgCat" in
    native|xeno) ;;
    *) echo "Error: invalid organism category \"$orgCat\" in mrna file name: $rnaBase" >&2
    exit 1;;
esac

# ooc chosen based on database
case "$database" in
    hg*) oocOpt="-ooc=${HG_OOC}" ;;
    mm*) oocOpt="-ooc=${MM_OOC}" ;;
    rn*) oocOpt="-ooc=${RN_OOC}" ;;
    ci*) ;;
    zooHuman*) oocOpt="-ooc=${HG_OOC}" ;;
    zooMouse*) oocOpt="-ooc=${MM_OOC}" ;;
    zooRat*) oocOpt="-ooc=${RN_OOC}" ;;
    zoo*) ;;
    *) echo "Error: gbBlat doesn't know how get ooc for database \"$database\"" >&2
        exit 1;;
esac


# determine blat parameters
case "$orgCat" in
    native)
        isNative=YES
        case "$type" in
            mrna)
                if [ "$srcDb" = "refseq" ] ; then
                    # -trimHardA was recommended, however this results in
                    # qSize being less than the sequence size.
                    blatParams="-q=rna -fine $oocOpt"
                else
                    blatParams="-q=rna -fine $oocOpt"
                fi
                ;;
            est)
                blatParams="-mask=lower $oocOpt" ;;
        esac;;
    xeno) 
        isNative=NO
        case "$type" in
            mrna)
                blatParams="-q=rnax -t=dnax -mask=lower";;
            est)
                blatParams="-q=dnax -t=dnax -mask=lower";;
        esac;;
esac

# local directory for all work.
tmpDir="/var/tmp/gbBlat.$$.tmp"
rm -rf $tmpDir
mkdir -p -m 02775 $tmpDir

# create out directory now, so mkdir failure (usually NFS) will not happen
# after blat has completed.  Try twice, just because we sometimes get 
# weird failures.  Maintain group write/sticky
mkdir -p -m 02775 $outDir || (sleep 2 && mkdir -p -m 02775 $outDir)

# arrange for cleanup on any exit
if [ "x$keepTmp" = "xYES" ] ; then
    echo will keep tmpDir `hostname` $tmpDir
else
    trap "rm -rf $tmpDir" EXIT
fi

# run blat, don't create header, so we can just cat together later
localPsl="$tmpDir/$outBase.psl"
$BLAT -noHead $blatParams $genomeFile $rnaFa $localPsl

# orientation info info and ESTs w/intron selection is only done for
# native and if the output file length is greater than zero
if [ -s $localPsl -a $isNative == "YES" ] ; then
    # get orientation info
    localOi="$tmpDir/$outBase.oi"
    $POLYINFO $localPsl $genomeFile $rnaFa $localOi

    # if these are native ESTs, select ones that have introns, saving only
    # if some actually exist.
    localIntronPsl="$tmpDir/$outBase.intronPsl"
    if [ $type == "est" ] ; then
        $PSL_INTRONS_ONLY $localPsl $genomeFile $localIntronPsl
        if [ -s $localPsl ] ; then
            cp $localIntronPsl $outIntronPsl.tmp
            mv -f $outIntronPsl.tmp $outIntronPsl
        else
            rm -f $localIntronPsl
        fi
    fi

    # copy into place, oi first, since it's the derived data and useless
    # without the psl.
    cp $localOi $outOi.tmp
    mv -f $outOi.tmp $outOi
fi

# always install psl last, even if empty, to indicate completion
cp $localPsl $outPsl.tmp
mv -f $outPsl.tmp $outPsl
