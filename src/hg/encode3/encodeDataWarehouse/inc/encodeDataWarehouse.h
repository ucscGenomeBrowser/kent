/* encodeDataWarehouse.h was originally generated by the autoSql program, which also 
 * generated encodeDataWarehouse.c and encodeDataWarehouse.sql.  This header links the database and
 * the RAM representation of objects. */

#ifndef ENCODEDATAWAREHOUSE_H
#define ENCODEDATAWAREHOUSE_H

#include "jksql.h"
#define EDWUSER_NUM_COLS 5

struct edwUser
/* Someone who submits files to or otherwise interacts with big data warehouse */
    {
    struct edwUser *next;  /* Next in singly linked list. */
    unsigned id;	/* Autoincremented user ID */
    char *name;	/* user name */
    char sid[65];	/* sha384 generated user ID - used to identify user in secure way if need be */
    char access[65];	/* access code - sha385'd from password and stuff */
    char *email;	/* Email address - required */
    };

void edwUserStaticLoad(char **row, struct edwUser *ret);
/* Load a row from edwUser table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwUser *edwUserLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwUser from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwUserFreeList(). */

void edwUserSaveToDb(struct sqlConnection *conn, struct edwUser *el, char *tableName, int updateSize);
/* Save edwUser as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwUserSaveToDbEscaped() */

void edwUserSaveToDbEscaped(struct sqlConnection *conn, struct edwUser *el, char *tableName, int updateSize);
/* Save edwUser as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwUserSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwUser *edwUserLoad(char **row);
/* Load a edwUser from row fetched with select * from edwUser
 * from database.  Dispose of this with edwUserFree(). */

struct edwUser *edwUserLoadAll(char *fileName);
/* Load all edwUser from whitespace-separated file.
 * Dispose of this with edwUserFreeList(). */

struct edwUser *edwUserLoadAllByChar(char *fileName, char chopper);
/* Load all edwUser from chopper separated file.
 * Dispose of this with edwUserFreeList(). */

#define edwUserLoadAllByTab(a) edwUserLoadAllByChar(a, '\t');
/* Load all edwUser from tab separated file.
 * Dispose of this with edwUserFreeList(). */

struct edwUser *edwUserCommaIn(char **pS, struct edwUser *ret);
/* Create a edwUser out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwUser */

void edwUserFree(struct edwUser **pEl);
/* Free a single dynamically allocated edwUser such as created
 * with edwUserLoad(). */

void edwUserFreeList(struct edwUser **pList);
/* Free a list of dynamically allocated edwUser's */

void edwUserOutput(struct edwUser *el, FILE *f, char sep, char lastSep);
/* Print out edwUser.  Separate fields with sep. Follow last field with lastSep. */

#define edwUserTabOut(el,f) edwUserOutput(el,f,'\t','\n');
/* Print out edwUser as a line in a tab-separated file. */

#define edwUserCommaOut(el,f) edwUserOutput(el,f,',',',');
/* Print out edwUser as a comma separated list including final comma. */

#define EDWHOST_NUM_COLS 9

struct edwHost
/* A web host we have collected files from - something like www.ncbi.nlm.gov or google.com */
    {
    struct edwHost *next;  /* Next in singly linked list. */
    unsigned id;	/* Autoincremented host id */
    char *name;	/* Name (before DNS lookup) */
    long long lastOkTime;	/* Last time host was ok in seconds since 1970 */
    long long lastNotOkTime;	/* Last time host was not ok in seconds since 1970 */
    long long firstAdded;	/* Time host was first seen */
    char *errorMessage;	/* If non-empty contains last error message from host. If empty host is ok */
    long long openSuccesses;	/* Number of times files have been opened ok from this host */
    long long openFails;	/* Number of times files have failed to open from this host */
    long long historyBits;	/* Open history with most recent in least significant bit. 0 for connection failed, 1 for success */
    };

void edwHostStaticLoad(char **row, struct edwHost *ret);
/* Load a row from edwHost table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwHost *edwHostLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwHost from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwHostFreeList(). */

void edwHostSaveToDb(struct sqlConnection *conn, struct edwHost *el, char *tableName, int updateSize);
/* Save edwHost as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwHostSaveToDbEscaped() */

void edwHostSaveToDbEscaped(struct sqlConnection *conn, struct edwHost *el, char *tableName, int updateSize);
/* Save edwHost as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwHostSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwHost *edwHostLoad(char **row);
/* Load a edwHost from row fetched with select * from edwHost
 * from database.  Dispose of this with edwHostFree(). */

struct edwHost *edwHostLoadAll(char *fileName);
/* Load all edwHost from whitespace-separated file.
 * Dispose of this with edwHostFreeList(). */

struct edwHost *edwHostLoadAllByChar(char *fileName, char chopper);
/* Load all edwHost from chopper separated file.
 * Dispose of this with edwHostFreeList(). */

#define edwHostLoadAllByTab(a) edwHostLoadAllByChar(a, '\t');
/* Load all edwHost from tab separated file.
 * Dispose of this with edwHostFreeList(). */

struct edwHost *edwHostCommaIn(char **pS, struct edwHost *ret);
/* Create a edwHost out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwHost */

void edwHostFree(struct edwHost **pEl);
/* Free a single dynamically allocated edwHost such as created
 * with edwHostLoad(). */

void edwHostFreeList(struct edwHost **pList);
/* Free a list of dynamically allocated edwHost's */

void edwHostOutput(struct edwHost *el, FILE *f, char sep, char lastSep);
/* Print out edwHost.  Separate fields with sep. Follow last field with lastSep. */

#define edwHostTabOut(el,f) edwHostOutput(el,f,'\t','\n');
/* Print out edwHost as a line in a tab-separated file. */

#define edwHostCommaOut(el,f) edwHostOutput(el,f,',',',');
/* Print out edwHost as a comma separated list including final comma. */

#define EDWSUBMITDIR_NUM_COLS 10

struct edwSubmitDir
/* An external data directory we have collected a submit from */
    {
    struct edwSubmitDir *next;  /* Next in singly linked list. */
    unsigned id;	/* Autoincremented id */
    char *url;	/* Web-mounted directory. Includes protocol, host, and final '/' */
    unsigned hostId;	/* Id of host it's on */
    long long lastOkTime;	/* Last time submit dir was ok in seconds since 1970 */
    long long lastNotOkTime;	/* Last time submit dir was not ok in seconds since 1970 */
    long long firstAdded;	/* Time submit dir was first seen */
    char *errorMessage;	/* If non-empty contains last error message from dir. If empty dir is ok */
    long long openSuccesses;	/* Number of times files have been opened ok from this dir */
    long long openFails;	/* Number of times files have failed to open from this dir */
    long long historyBits;	/* Open history with most recent in least significant bit. 0 for upload failed, 1 for success */
    };

void edwSubmitDirStaticLoad(char **row, struct edwSubmitDir *ret);
/* Load a row from edwSubmitDir table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwSubmitDir *edwSubmitDirLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwSubmitDir from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwSubmitDirFreeList(). */

void edwSubmitDirSaveToDb(struct sqlConnection *conn, struct edwSubmitDir *el, char *tableName, int updateSize);
/* Save edwSubmitDir as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwSubmitDirSaveToDbEscaped() */

void edwSubmitDirSaveToDbEscaped(struct sqlConnection *conn, struct edwSubmitDir *el, char *tableName, int updateSize);
/* Save edwSubmitDir as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwSubmitDirSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwSubmitDir *edwSubmitDirLoad(char **row);
/* Load a edwSubmitDir from row fetched with select * from edwSubmitDir
 * from database.  Dispose of this with edwSubmitDirFree(). */

struct edwSubmitDir *edwSubmitDirLoadAll(char *fileName);
/* Load all edwSubmitDir from whitespace-separated file.
 * Dispose of this with edwSubmitDirFreeList(). */

struct edwSubmitDir *edwSubmitDirLoadAllByChar(char *fileName, char chopper);
/* Load all edwSubmitDir from chopper separated file.
 * Dispose of this with edwSubmitDirFreeList(). */

#define edwSubmitDirLoadAllByTab(a) edwSubmitDirLoadAllByChar(a, '\t');
/* Load all edwSubmitDir from tab separated file.
 * Dispose of this with edwSubmitDirFreeList(). */

struct edwSubmitDir *edwSubmitDirCommaIn(char **pS, struct edwSubmitDir *ret);
/* Create a edwSubmitDir out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmitDir */

void edwSubmitDirFree(struct edwSubmitDir **pEl);
/* Free a single dynamically allocated edwSubmitDir such as created
 * with edwSubmitDirLoad(). */

void edwSubmitDirFreeList(struct edwSubmitDir **pList);
/* Free a list of dynamically allocated edwSubmitDir's */

void edwSubmitDirOutput(struct edwSubmitDir *el, FILE *f, char sep, char lastSep);
/* Print out edwSubmitDir.  Separate fields with sep. Follow last field with lastSep. */

#define edwSubmitDirTabOut(el,f) edwSubmitDirOutput(el,f,'\t','\n');
/* Print out edwSubmitDir as a line in a tab-separated file. */

#define edwSubmitDirCommaOut(el,f) edwSubmitDirOutput(el,f,',',',');
/* Print out edwSubmitDir as a comma separated list including final comma. */

#define EDWFILE_NUM_COLS 15

struct edwFile
/* A file we are tracking that we intend to and maybe have uploaded */
    {
    struct edwFile *next;  /* Next in singly linked list. */
    unsigned id;	/* Autoincrementing file id */
    char licensePlate[17];	/* A abc123 looking license-platish thing */
    unsigned submitId;	/* Links to id in submit table */
    unsigned submitDirId;	/* Links to id in submitDir table */
    char *submitFileName;	/* File name in submit relative to submit dir */
    char *edwFileName;	/* File name in big data warehouse relative to edw root dir */
    long long startUploadTime;	/* Time when upload started - 0 if not started */
    long long endUploadTime;	/* Time when upload finished - 0 if not finished */
    long long updateTime;	/* Update time (on system it was uploaded from) */
    long long size;	/* File size */
    char md5[33];	/* md5 sum of file contents */
    char *tags;	/* CGI encoded name=val pairs from manifest */
    char *errorMessage;	/* If non-empty contains last error message from upload. If empty upload is ok */
    char *deprecated;	/* If non-empty why you shouldn't user this file any more. */
    char *replacedBy;	/* If non-empty license plate of file that replaces this one. */
    };

void edwFileStaticLoad(char **row, struct edwFile *ret);
/* Load a row from edwFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwFile *edwFileLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwFile from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwFileFreeList(). */

void edwFileSaveToDb(struct sqlConnection *conn, struct edwFile *el, char *tableName, int updateSize);
/* Save edwFile as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwFileSaveToDbEscaped() */

void edwFileSaveToDbEscaped(struct sqlConnection *conn, struct edwFile *el, char *tableName, int updateSize);
/* Save edwFile as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwFileSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwFile *edwFileLoad(char **row);
/* Load a edwFile from row fetched with select * from edwFile
 * from database.  Dispose of this with edwFileFree(). */

struct edwFile *edwFileLoadAll(char *fileName);
/* Load all edwFile from whitespace-separated file.
 * Dispose of this with edwFileFreeList(). */

struct edwFile *edwFileLoadAllByChar(char *fileName, char chopper);
/* Load all edwFile from chopper separated file.
 * Dispose of this with edwFileFreeList(). */

#define edwFileLoadAllByTab(a) edwFileLoadAllByChar(a, '\t');
/* Load all edwFile from tab separated file.
 * Dispose of this with edwFileFreeList(). */

struct edwFile *edwFileCommaIn(char **pS, struct edwFile *ret);
/* Create a edwFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwFile */

void edwFileFree(struct edwFile **pEl);
/* Free a single dynamically allocated edwFile such as created
 * with edwFileLoad(). */

void edwFileFreeList(struct edwFile **pList);
/* Free a list of dynamically allocated edwFile's */

void edwFileOutput(struct edwFile *el, FILE *f, char sep, char lastSep);
/* Print out edwFile.  Separate fields with sep. Follow last field with lastSep. */

#define edwFileTabOut(el,f) edwFileOutput(el,f,'\t','\n');
/* Print out edwFile as a line in a tab-separated file. */

#define edwFileCommaOut(el,f) edwFileOutput(el,f,',',',');
/* Print out edwFile as a comma separated list including final comma. */

#define EDWSUBMIT_NUM_COLS 11

struct edwSubmit
/* A data submit, typically containing many files.  Always associated with a submit dir. */
    {
    struct edwSubmit *next;  /* Next in singly linked list. */
    unsigned id;	/* Autoincremented submit id */
    char *url;	/* Url to validated.txt format file. We copy this file over and give it a fileId if we can. */
    long long startUploadTime;	/* Time at start of submit */
    long long endUploadTime;	/* Time at end of upload - 0 if not finished */
    unsigned userId;	/* Connects to user table id field */
    unsigned submitFileId;	/* Points to validated.txt file for submit. */
    unsigned submitDirId;	/* Points to the submitDir */
    unsigned fileCount;	/* Number of files that will be in submit if it were complete. */
    unsigned oldFiles;	/* Number of files in submission that were already in warehouse. */
    unsigned newFiles;	/* Number of files in submission that are newly uploaded. */
    char *errorMessage;	/* If non-empty contains last error message. If empty submit is ok */
    };

void edwSubmitStaticLoad(char **row, struct edwSubmit *ret);
/* Load a row from edwSubmit table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwSubmit *edwSubmitLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwSubmit from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwSubmitFreeList(). */

void edwSubmitSaveToDb(struct sqlConnection *conn, struct edwSubmit *el, char *tableName, int updateSize);
/* Save edwSubmit as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwSubmitSaveToDbEscaped() */

void edwSubmitSaveToDbEscaped(struct sqlConnection *conn, struct edwSubmit *el, char *tableName, int updateSize);
/* Save edwSubmit as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwSubmitSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwSubmit *edwSubmitLoad(char **row);
/* Load a edwSubmit from row fetched with select * from edwSubmit
 * from database.  Dispose of this with edwSubmitFree(). */

struct edwSubmit *edwSubmitLoadAll(char *fileName);
/* Load all edwSubmit from whitespace-separated file.
 * Dispose of this with edwSubmitFreeList(). */

struct edwSubmit *edwSubmitLoadAllByChar(char *fileName, char chopper);
/* Load all edwSubmit from chopper separated file.
 * Dispose of this with edwSubmitFreeList(). */

#define edwSubmitLoadAllByTab(a) edwSubmitLoadAllByChar(a, '\t');
/* Load all edwSubmit from tab separated file.
 * Dispose of this with edwSubmitFreeList(). */

struct edwSubmit *edwSubmitCommaIn(char **pS, struct edwSubmit *ret);
/* Create a edwSubmit out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubmit */

void edwSubmitFree(struct edwSubmit **pEl);
/* Free a single dynamically allocated edwSubmit such as created
 * with edwSubmitLoad(). */

void edwSubmitFreeList(struct edwSubmit **pList);
/* Free a list of dynamically allocated edwSubmit's */

void edwSubmitOutput(struct edwSubmit *el, FILE *f, char sep, char lastSep);
/* Print out edwSubmit.  Separate fields with sep. Follow last field with lastSep. */

#define edwSubmitTabOut(el,f) edwSubmitOutput(el,f,'\t','\n');
/* Print out edwSubmit as a line in a tab-separated file. */

#define edwSubmitCommaOut(el,f) edwSubmitOutput(el,f,',',',');
/* Print out edwSubmit as a comma separated list including final comma. */

#define EDWSUBSCRIBER_NUM_COLS 7

struct edwSubscriber
/* Subscribers can have programs that are called at various points during data submission */
    {
    struct edwSubscriber *next;  /* Next in singly linked list. */
    unsigned id;	/* ID of subscriber */
    char *name;	/* Name of subscriber */
    double runOrder;	/* Determines order subscribers run in. In case of tie lowest id wins. */
    char *filePattern;	/* A string with * and ? wildcards to match files we care about */
    char *dirPattern;	/* A string with * and ? wildcards to match hub dir URLs we care about */
    char *tagPattern;	/* A cgi-encoded string of tag=wildcard pairs. */
    char *onFileEndUpload;	/* A unix command string to run with a %u where file id goes */
    };

void edwSubscriberStaticLoad(char **row, struct edwSubscriber *ret);
/* Load a row from edwSubscriber table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwSubscriber *edwSubscriberLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwSubscriber from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwSubscriberFreeList(). */

void edwSubscriberSaveToDb(struct sqlConnection *conn, struct edwSubscriber *el, char *tableName, int updateSize);
/* Save edwSubscriber as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwSubscriberSaveToDbEscaped() */

void edwSubscriberSaveToDbEscaped(struct sqlConnection *conn, struct edwSubscriber *el, char *tableName, int updateSize);
/* Save edwSubscriber as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwSubscriberSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwSubscriber *edwSubscriberLoad(char **row);
/* Load a edwSubscriber from row fetched with select * from edwSubscriber
 * from database.  Dispose of this with edwSubscriberFree(). */

struct edwSubscriber *edwSubscriberLoadAll(char *fileName);
/* Load all edwSubscriber from whitespace-separated file.
 * Dispose of this with edwSubscriberFreeList(). */

struct edwSubscriber *edwSubscriberLoadAllByChar(char *fileName, char chopper);
/* Load all edwSubscriber from chopper separated file.
 * Dispose of this with edwSubscriberFreeList(). */

#define edwSubscriberLoadAllByTab(a) edwSubscriberLoadAllByChar(a, '\t');
/* Load all edwSubscriber from tab separated file.
 * Dispose of this with edwSubscriberFreeList(). */

struct edwSubscriber *edwSubscriberCommaIn(char **pS, struct edwSubscriber *ret);
/* Create a edwSubscriber out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwSubscriber */

void edwSubscriberFree(struct edwSubscriber **pEl);
/* Free a single dynamically allocated edwSubscriber such as created
 * with edwSubscriberLoad(). */

void edwSubscriberFreeList(struct edwSubscriber **pList);
/* Free a list of dynamically allocated edwSubscriber's */

void edwSubscriberOutput(struct edwSubscriber *el, FILE *f, char sep, char lastSep);
/* Print out edwSubscriber.  Separate fields with sep. Follow last field with lastSep. */

#define edwSubscriberTabOut(el,f) edwSubscriberOutput(el,f,'\t','\n');
/* Print out edwSubscriber as a line in a tab-separated file. */

#define edwSubscriberCommaOut(el,f) edwSubscriberOutput(el,f,',',',');
/* Print out edwSubscriber as a comma separated list including final comma. */

#define EDWASSEMBLY_NUM_COLS 6

struct edwAssembly
/* An assembly - includes reference to a two bit file, and a little name and summary info. */
    {
    struct edwAssembly *next;  /* Next in singly linked list. */
    unsigned id;	/* Assembly ID */
    unsigned taxon;	/* NCBI taxon number */
    char *name;	/* Some human readable name to distinguish this from other collections of DNA */
    char *ucscDb;	/* Which UCSC database (mm9?  hg19?) associated with it. */
    unsigned twoBitId;	/* File ID of associated twoBit file */
    long long baseCount;	/* Count of bases */
    };

void edwAssemblyStaticLoad(char **row, struct edwAssembly *ret);
/* Load a row from edwAssembly table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwAssembly *edwAssemblyLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwAssembly from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwAssemblyFreeList(). */

void edwAssemblySaveToDb(struct sqlConnection *conn, struct edwAssembly *el, char *tableName, int updateSize);
/* Save edwAssembly as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwAssemblySaveToDbEscaped() */

void edwAssemblySaveToDbEscaped(struct sqlConnection *conn, struct edwAssembly *el, char *tableName, int updateSize);
/* Save edwAssembly as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwAssemblySaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwAssembly *edwAssemblyLoad(char **row);
/* Load a edwAssembly from row fetched with select * from edwAssembly
 * from database.  Dispose of this with edwAssemblyFree(). */

struct edwAssembly *edwAssemblyLoadAll(char *fileName);
/* Load all edwAssembly from whitespace-separated file.
 * Dispose of this with edwAssemblyFreeList(). */

struct edwAssembly *edwAssemblyLoadAllByChar(char *fileName, char chopper);
/* Load all edwAssembly from chopper separated file.
 * Dispose of this with edwAssemblyFreeList(). */

#define edwAssemblyLoadAllByTab(a) edwAssemblyLoadAllByChar(a, '\t');
/* Load all edwAssembly from tab separated file.
 * Dispose of this with edwAssemblyFreeList(). */

struct edwAssembly *edwAssemblyCommaIn(char **pS, struct edwAssembly *ret);
/* Create a edwAssembly out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwAssembly */

void edwAssemblyFree(struct edwAssembly **pEl);
/* Free a single dynamically allocated edwAssembly such as created
 * with edwAssemblyLoad(). */

void edwAssemblyFreeList(struct edwAssembly **pList);
/* Free a list of dynamically allocated edwAssembly's */

void edwAssemblyOutput(struct edwAssembly *el, FILE *f, char sep, char lastSep);
/* Print out edwAssembly.  Separate fields with sep. Follow last field with lastSep. */

#define edwAssemblyTabOut(el,f) edwAssemblyOutput(el,f,'\t','\n');
/* Print out edwAssembly as a line in a tab-separated file. */

#define edwAssemblyCommaOut(el,f) edwAssemblyOutput(el,f,',',',');
/* Print out edwAssembly as a comma separated list including final comma. */

#define EDWVALIDFILE_NUM_COLS 17

struct edwValidFile
/* A file that has been uploaded, the format checked, and for which at least minimal metadata exists */
    {
    struct edwValidFile *next;  /* Next in singly linked list. */
    unsigned id;	/* ID of validated file */
    char licensePlate[17];	/* A abc123 looking license-platish thing. Same as in edwFile table */
    unsigned fileId;	/* Pointer to file in main file table */
    char *format;	/* What format it's in from manifest */
    char *outputType;	/* What output_type it is from manifest */
    char *experiment;	/* What experiment it's in from manifest */
    char *replicate;	/* What replicate it is from manifest */
    char *validKey;	/* The valid_key tag from manifest */
    char *enrichedIn;	/* The enriched_in tag from manifest */
    char *ucscDb;	/* Something like hg19 or mm9 */
    long long itemCount;	/* # of items in file: reads for fastqs, lines for beds, bases w/data for wig. */
    long long basesInItems;	/* # of bases in items */
    char *samplePath;	/* Path to a temporary sample file */
    long long sampleCount;	/* # of items in sample if we are just subsampling as we do for reads. */
    long long basesInSample;	/* # of bases in our sample */
    double sampleCoverage;	/* Proportion of assembly covered by at least one item in sample */
    double depth;	/* Estimated genome-equivalents covered by possibly overlapping data */
    };

void edwValidFileStaticLoad(char **row, struct edwValidFile *ret);
/* Load a row from edwValidFile table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwValidFile *edwValidFileLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwValidFile from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwValidFileFreeList(). */

void edwValidFileSaveToDb(struct sqlConnection *conn, struct edwValidFile *el, char *tableName, int updateSize);
/* Save edwValidFile as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwValidFileSaveToDbEscaped() */

void edwValidFileSaveToDbEscaped(struct sqlConnection *conn, struct edwValidFile *el, char *tableName, int updateSize);
/* Save edwValidFile as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwValidFileSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwValidFile *edwValidFileLoad(char **row);
/* Load a edwValidFile from row fetched with select * from edwValidFile
 * from database.  Dispose of this with edwValidFileFree(). */

struct edwValidFile *edwValidFileLoadAll(char *fileName);
/* Load all edwValidFile from whitespace-separated file.
 * Dispose of this with edwValidFileFreeList(). */

struct edwValidFile *edwValidFileLoadAllByChar(char *fileName, char chopper);
/* Load all edwValidFile from chopper separated file.
 * Dispose of this with edwValidFileFreeList(). */

#define edwValidFileLoadAllByTab(a) edwValidFileLoadAllByChar(a, '\t');
/* Load all edwValidFile from tab separated file.
 * Dispose of this with edwValidFileFreeList(). */

struct edwValidFile *edwValidFileCommaIn(char **pS, struct edwValidFile *ret);
/* Create a edwValidFile out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwValidFile */

void edwValidFileFree(struct edwValidFile **pEl);
/* Free a single dynamically allocated edwValidFile such as created
 * with edwValidFileLoad(). */

void edwValidFileFreeList(struct edwValidFile **pList);
/* Free a list of dynamically allocated edwValidFile's */

void edwValidFileOutput(struct edwValidFile *el, FILE *f, char sep, char lastSep);
/* Print out edwValidFile.  Separate fields with sep. Follow last field with lastSep. */

#define edwValidFileTabOut(el,f) edwValidFileOutput(el,f,'\t','\n');
/* Print out edwValidFile as a line in a tab-separated file. */

#define edwValidFileCommaOut(el,f) edwValidFileOutput(el,f,',',',');
/* Print out edwValidFile as a comma separated list including final comma. */

#define EDWQAAGENT_NUM_COLS 5

struct edwQaAgent
/* A program plus parameters with a standard command line that gets run on new files */
    {
    struct edwQaAgent *next;  /* Next in singly linked list. */
    unsigned id;	/* ID of this agent */
    char *name;	/* Name of agent */
    char *program;	/* Program command line name */
    char *options;	/* Program command line options */
    char *deprecated;	/* If non-empty why it isn't run any more. */
    };

void edwQaAgentStaticLoad(char **row, struct edwQaAgent *ret);
/* Load a row from edwQaAgent table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwQaAgent *edwQaAgentLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwQaAgent from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwQaAgentFreeList(). */

void edwQaAgentSaveToDb(struct sqlConnection *conn, struct edwQaAgent *el, char *tableName, int updateSize);
/* Save edwQaAgent as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwQaAgentSaveToDbEscaped() */

void edwQaAgentSaveToDbEscaped(struct sqlConnection *conn, struct edwQaAgent *el, char *tableName, int updateSize);
/* Save edwQaAgent as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwQaAgentSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwQaAgent *edwQaAgentLoad(char **row);
/* Load a edwQaAgent from row fetched with select * from edwQaAgent
 * from database.  Dispose of this with edwQaAgentFree(). */

struct edwQaAgent *edwQaAgentLoadAll(char *fileName);
/* Load all edwQaAgent from whitespace-separated file.
 * Dispose of this with edwQaAgentFreeList(). */

struct edwQaAgent *edwQaAgentLoadAllByChar(char *fileName, char chopper);
/* Load all edwQaAgent from chopper separated file.
 * Dispose of this with edwQaAgentFreeList(). */

#define edwQaAgentLoadAllByTab(a) edwQaAgentLoadAllByChar(a, '\t');
/* Load all edwQaAgent from tab separated file.
 * Dispose of this with edwQaAgentFreeList(). */

struct edwQaAgent *edwQaAgentCommaIn(char **pS, struct edwQaAgent *ret);
/* Create a edwQaAgent out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaAgent */

void edwQaAgentFree(struct edwQaAgent **pEl);
/* Free a single dynamically allocated edwQaAgent such as created
 * with edwQaAgentLoad(). */

void edwQaAgentFreeList(struct edwQaAgent **pList);
/* Free a list of dynamically allocated edwQaAgent's */

void edwQaAgentOutput(struct edwQaAgent *el, FILE *f, char sep, char lastSep);
/* Print out edwQaAgent.  Separate fields with sep. Follow last field with lastSep. */

#define edwQaAgentTabOut(el,f) edwQaAgentOutput(el,f,'\t','\n');
/* Print out edwQaAgent as a line in a tab-separated file. */

#define edwQaAgentCommaOut(el,f) edwQaAgentOutput(el,f,',',',');
/* Print out edwQaAgent as a comma separated list including final comma. */

#define EDWQARUN_NUM_COLS 7

struct edwQaRun
/* Records a bit of information from each QA run we've done on files. */
    {
    struct edwQaRun *next;  /* Next in singly linked list. */
    unsigned id;	/* ID of this run */
    unsigned agentId;	/* ID of agent that made this run */
    unsigned startFileId;	/* ID of file we started on. */
    unsigned endFileId;	/* One past last file we did QA on */
    long long startTime;	/* Start time in seconds since 1970 */
    long long endTime;	/* Start time in seconds since 1970 */
    char *stderr;	/* The output to stderr of the run */
    };

void edwQaRunStaticLoad(char **row, struct edwQaRun *ret);
/* Load a row from edwQaRun table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwQaRun *edwQaRunLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwQaRun from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwQaRunFreeList(). */

void edwQaRunSaveToDb(struct sqlConnection *conn, struct edwQaRun *el, char *tableName, int updateSize);
/* Save edwQaRun as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwQaRunSaveToDbEscaped() */

void edwQaRunSaveToDbEscaped(struct sqlConnection *conn, struct edwQaRun *el, char *tableName, int updateSize);
/* Save edwQaRun as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwQaRunSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwQaRun *edwQaRunLoad(char **row);
/* Load a edwQaRun from row fetched with select * from edwQaRun
 * from database.  Dispose of this with edwQaRunFree(). */

struct edwQaRun *edwQaRunLoadAll(char *fileName);
/* Load all edwQaRun from whitespace-separated file.
 * Dispose of this with edwQaRunFreeList(). */

struct edwQaRun *edwQaRunLoadAllByChar(char *fileName, char chopper);
/* Load all edwQaRun from chopper separated file.
 * Dispose of this with edwQaRunFreeList(). */

#define edwQaRunLoadAllByTab(a) edwQaRunLoadAllByChar(a, '\t');
/* Load all edwQaRun from tab separated file.
 * Dispose of this with edwQaRunFreeList(). */

struct edwQaRun *edwQaRunCommaIn(char **pS, struct edwQaRun *ret);
/* Create a edwQaRun out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaRun */

void edwQaRunFree(struct edwQaRun **pEl);
/* Free a single dynamically allocated edwQaRun such as created
 * with edwQaRunLoad(). */

void edwQaRunFreeList(struct edwQaRun **pList);
/* Free a list of dynamically allocated edwQaRun's */

void edwQaRunOutput(struct edwQaRun *el, FILE *f, char sep, char lastSep);
/* Print out edwQaRun.  Separate fields with sep. Follow last field with lastSep. */

#define edwQaRunTabOut(el,f) edwQaRunOutput(el,f,'\t','\n');
/* Print out edwQaRun as a line in a tab-separated file. */

#define edwQaRunCommaOut(el,f) edwQaRunOutput(el,f,',',',');
/* Print out edwQaRun as a comma separated list including final comma. */

#define EDWQAENRICHTARGET_NUM_COLS 5

struct edwQaEnrichTarget
/* A target for our enrichment analysis. */
    {
    struct edwQaEnrichTarget *next;  /* Next in singly linked list. */
    unsigned id;	/* ID of this enrichment target */
    unsigned assemblyId;	/* Which assembly this goes to */
    char *name;	/* Something like 'exon' or 'promoter' */
    unsigned fileId;	/* A simple BED 3 format file that defines target. Bases covered are unique */
    long long targetSize;	/* Total number of bases covered by target */
    };

void edwQaEnrichTargetStaticLoad(char **row, struct edwQaEnrichTarget *ret);
/* Load a row from edwQaEnrichTarget table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwQaEnrichTarget *edwQaEnrichTargetLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwQaEnrichTarget from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwQaEnrichTargetFreeList(). */

void edwQaEnrichTargetSaveToDb(struct sqlConnection *conn, struct edwQaEnrichTarget *el, char *tableName, int updateSize);
/* Save edwQaEnrichTarget as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwQaEnrichTargetSaveToDbEscaped() */

void edwQaEnrichTargetSaveToDbEscaped(struct sqlConnection *conn, struct edwQaEnrichTarget *el, char *tableName, int updateSize);
/* Save edwQaEnrichTarget as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwQaEnrichTargetSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwQaEnrichTarget *edwQaEnrichTargetLoad(char **row);
/* Load a edwQaEnrichTarget from row fetched with select * from edwQaEnrichTarget
 * from database.  Dispose of this with edwQaEnrichTargetFree(). */

struct edwQaEnrichTarget *edwQaEnrichTargetLoadAll(char *fileName);
/* Load all edwQaEnrichTarget from whitespace-separated file.
 * Dispose of this with edwQaEnrichTargetFreeList(). */

struct edwQaEnrichTarget *edwQaEnrichTargetLoadAllByChar(char *fileName, char chopper);
/* Load all edwQaEnrichTarget from chopper separated file.
 * Dispose of this with edwQaEnrichTargetFreeList(). */

#define edwQaEnrichTargetLoadAllByTab(a) edwQaEnrichTargetLoadAllByChar(a, '\t');
/* Load all edwQaEnrichTarget from tab separated file.
 * Dispose of this with edwQaEnrichTargetFreeList(). */

struct edwQaEnrichTarget *edwQaEnrichTargetCommaIn(char **pS, struct edwQaEnrichTarget *ret);
/* Create a edwQaEnrichTarget out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaEnrichTarget */

void edwQaEnrichTargetFree(struct edwQaEnrichTarget **pEl);
/* Free a single dynamically allocated edwQaEnrichTarget such as created
 * with edwQaEnrichTargetLoad(). */

void edwQaEnrichTargetFreeList(struct edwQaEnrichTarget **pList);
/* Free a list of dynamically allocated edwQaEnrichTarget's */

void edwQaEnrichTargetOutput(struct edwQaEnrichTarget *el, FILE *f, char sep, char lastSep);
/* Print out edwQaEnrichTarget.  Separate fields with sep. Follow last field with lastSep. */

#define edwQaEnrichTargetTabOut(el,f) edwQaEnrichTargetOutput(el,f,'\t','\n');
/* Print out edwQaEnrichTarget as a line in a tab-separated file. */

#define edwQaEnrichTargetCommaOut(el,f) edwQaEnrichTargetOutput(el,f,',',',');
/* Print out edwQaEnrichTarget as a comma separated list including final comma. */

#define EDWQAENRICH_NUM_COLS 8

struct edwQaEnrich
/* An enrichment analysis applied to file. */
    {
    struct edwQaEnrich *next;  /* Next in singly linked list. */
    unsigned id;	/* ID of this enrichment analysis */
    unsigned fileId;	/* File we are looking at skeptically */
    unsigned qaEnrichTargetId;	/* Information about an target for this analysis */
    long long targetBaseHits;	/* Number of hits to bases in target */
    long long targetUniqHits;	/* Number of unique bases hit in target */
    double coverage;	/* Coverage of target - just targetUniqHits/targetSize */
    double enrichment;	/* Amount we hit target/amount we hit genome */
    double uniqEnrich;	/* coverage/sampleCoverage */
    };

void edwQaEnrichStaticLoad(char **row, struct edwQaEnrich *ret);
/* Load a row from edwQaEnrich table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct edwQaEnrich *edwQaEnrichLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all edwQaEnrich from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with edwQaEnrichFreeList(). */

void edwQaEnrichSaveToDb(struct sqlConnection *conn, struct edwQaEnrich *el, char *tableName, int updateSize);
/* Save edwQaEnrich as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use edwQaEnrichSaveToDbEscaped() */

void edwQaEnrichSaveToDbEscaped(struct sqlConnection *conn, struct edwQaEnrich *el, char *tableName, int updateSize);
/* Save edwQaEnrich as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than edwQaEnrichSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct edwQaEnrich *edwQaEnrichLoad(char **row);
/* Load a edwQaEnrich from row fetched with select * from edwQaEnrich
 * from database.  Dispose of this with edwQaEnrichFree(). */

struct edwQaEnrich *edwQaEnrichLoadAll(char *fileName);
/* Load all edwQaEnrich from whitespace-separated file.
 * Dispose of this with edwQaEnrichFreeList(). */

struct edwQaEnrich *edwQaEnrichLoadAllByChar(char *fileName, char chopper);
/* Load all edwQaEnrich from chopper separated file.
 * Dispose of this with edwQaEnrichFreeList(). */

#define edwQaEnrichLoadAllByTab(a) edwQaEnrichLoadAllByChar(a, '\t');
/* Load all edwQaEnrich from tab separated file.
 * Dispose of this with edwQaEnrichFreeList(). */

struct edwQaEnrich *edwQaEnrichCommaIn(char **pS, struct edwQaEnrich *ret);
/* Create a edwQaEnrich out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new edwQaEnrich */

void edwQaEnrichFree(struct edwQaEnrich **pEl);
/* Free a single dynamically allocated edwQaEnrich such as created
 * with edwQaEnrichLoad(). */

void edwQaEnrichFreeList(struct edwQaEnrich **pList);
/* Free a list of dynamically allocated edwQaEnrich's */

void edwQaEnrichOutput(struct edwQaEnrich *el, FILE *f, char sep, char lastSep);
/* Print out edwQaEnrich.  Separate fields with sep. Follow last field with lastSep. */

#define edwQaEnrichTabOut(el,f) edwQaEnrichOutput(el,f,'\t','\n');
/* Print out edwQaEnrich as a line in a tab-separated file. */

#define edwQaEnrichCommaOut(el,f) edwQaEnrichOutput(el,f,',',',');
/* Print out edwQaEnrich as a comma separated list including final comma. */

/* -------------------------------- End autoSql Generated Code -------------------------------- */

#endif /* ENCODEDATAWAREHOUSE_H */

