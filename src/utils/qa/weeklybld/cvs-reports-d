#!/bin/sh
# Start Tcl from a compbio bin directory \
exec /projects/compbio/bin/`uname -m`/tcl $0 ${1+"$@"}
package require Tclx 8.0.0

#
# Program to generate reports from CVS log.
#

#
# Notes:
#   since we quit generating the full diff, we could go back to
#   using rdiff, however some other file annotation might be done,
#   so this is left using a working directory




package require Itcl

#
# Class that contains the information about a file obtained from a cvs log
# command.
#
::itcl::class CVSFileInfo {
    # Serialization version number.
    private common SERIALIZE_VERSION 1

    # Fields to serialize
    private common SERIALIZE_FIELDS {
        fRcsFile fWorkingFile fHead fBranch
        fKeywordSubst fBranchTable fTags fTagTable fRevisions
    }

    # Separator for file records
    private common FILE_REC_SEP "============================================================================="

    # Separator for revision records
    private common REVISION_REC_SEP "----------------------------"

    # RCS file name (full repository path)
    private variable fRcsFile

    # Work file name (relative to current work directory)
    private variable fWorkingFile

    # Head and branch
    private variable fHead
    private variable fBranch

    # Keyword substitution
    private variable fKeywordSubst

    # Branch table, indexed by revision, with a list of branch revisions.
    # Doesn't contain unbranched revisions.
    private variable fBranchTable
    
    # Ordered list of tag names
    private variable fTags {}

    # Table of tags containing revision
    private variable fTagTable

    # Ordered list of revisions
    private variable fRevisions {}

    # Table of revisions information in the form:
    #    {rev dateTime author state comment}
    # dateTime is not parsed
    private variable fRevisionTable

    # Unexpect EOF error
    private proc unexpectedEOFError {} {
        error "Unexpect EOF parsing CVS log" {} {CVS CVS_LOG_UNEXPECTED_EOF}
    }

    # Parse error
    private proc parseError {msg} {
        error "CVS log parse error: $msg" {} {CVS CVS_LOG_PARSE}
    }

    # Read a line from the CVS log that must not return EOF.
    private proc readCvsLog {chan} {
        if {[gets $chan line] < 0} {
            unexpectedEOFError
        }
        return $line
    }

    # Determine if line is one of the record end lines.
    private proc isRecordEnd {line} {
        return [expr {[cequal $line $FILE_REC_SEP] || [cequal $line $REVISION_REC_SEP]}]
    }

    # typofix by galt alredy
    # Parse the cvs log header. `RCS file:' has already been read.
    private method parseCvsLogHeader {chan} {

        set parsingTags 0
        set inDescription 0
        while {1} {
            set line [readCvsLog $chan]
            if {[isRecordEnd $line]} {
                break
            }
            if {[string match "\t*" $line]} {
                # Process symbolic names line.
                if {!$parsingTags} {
                    parseError "unexpected symbolic names line: `$line'"
                }
                if {![regexp {^\t([^:]+): (.*)$} $line {} name value]} {
                    parseError "can't parse symbolic names line: `$line'"
                }
                lappend fTags $name
                set fTagTable($name) $value
		
            } elseif {!$inDescription} {
                if {![regexp {^([^:]+): *(.*)$} $line {} name value]} {
                    parseError "can't parse line: `$line'"
                }
                set parsingTags 0
                switch -- $name {
                    "RCS file" {
                        parseError "`RCS file:' should have already been parsed"
                    }
                    "Working file" {
                        set fWorkingFile $value
                    }
                    "head" {
                        set fHead $value
                    }
                    "branch" {
                        regsub -all {;} $value {} value
                        set fBranch $value
                    }
                    "symbolic names" {
                        set parsingTags 1
                    }
                    "keyword substitution" {
                        set fKeywordSubst $value
                    }
                    "description" {
                        set inDescription 1
                    }
                }
            }
        }
    }

    # Parse a commit record.  Return 1 if there are more to read,
    # zero if its the last.
    private method parseCvsLogCommitRec {chan} {
        set line [readCvsLog $chan]
        # Revision could have a `locked by:' (which is ignored)
        if {![regexp {^revision ([^;]+)} $line {} revision]} {
            parseError "invalid `revision' line, got `$line'"
        }
        set line [readCvsLog $chan]
	#galt fixed typo dataStr should be dateStr
        if {![regexp {^date: ([^;]+);  author: ([^;]+);  state: ([^;]+);} $line {} dateStr author state]} {
            parseError "invalid `date:' line, got `$line'"
        }
        # branches record is optional
        set line [readCvsLog $chan]
        if {[regexp {^branches: (.+;)} $line {} branchList]} {
            foreach branch $branchList {
                regsub -all {;| } $branch {} branch
                if {![lempty $branch]} {
                    lappend fBranchTable($revision) $branch
                }
            }
            set line [readCvsLog $chan]
        }
        # Rest is comment
        set comment {}
        while {1} {
            if {[isRecordEnd $line]} {
                break
            }
            append comment $line \n
            set line [readCvsLog $chan]
        }

        if {[cequal $comment "*** empty log message ***\n"]} {
            set comment {}
        }
        
        # Got it all
        lappend fRevisions $revision
	#galt fixed typo dataStr should be dateStr
        set fRevisionTable($revision) [list $revision $dateStr $author $state $comment]

        return [cequal $line $REVISION_REC_SEP]
    }

    # Parse the output of cvs log.
    private method parseCvsLog {chan {modulePath {}}} {
        parseCvsLogHeader $chan
        while {[parseCvsLogCommitRec $chan]} {
            continue
        }
        if {![info exists fWorkingFile]} {
            if {[lempty $modulePath]} {
                error "didn't parse work file and don't have module path: $fRcsFile"
            }
            if {[string first $modulePath $fRcsFile] != 0} {
                error "rcs file \"$fRcsFile\" doesn't start with module path \"$modulePath\""
            }
            set fWorkingFile [string range $fRcsFile [expr [string length $modulePath]+1] end]
            regsub {,v$} $fWorkingFile {} fWorkingFile
        }
    }

    # Parse a cvs log record and create an object for it.
    # Module path is needed to computer work directory if doing a rlog
    # Return {} on EOF.
    public proc readCvsLogRec {chan {modulePath {}}} {
        # Skip blank and `?" lines
        while {([gets $chan line] >= 0) \
                && ([lempty $line] || [string match \\?* $line])} {
            continue
        }
        if {[eof $chan]} {
            return {}
        }
        if {![regexp {^RCS file: (.*)$} $line {} value]} {
            parseError "Expected `RCS file:' line, got `$line'"
        }
        set obj [CVSFileInfo "::#auto" $value]
        try_eval {
            $obj parseCvsLog $chan $modulePath
        } {
            $obj delete
            error $errorResult $errorInfo $errorCode
        }
        return $obj
    }

    # Constructor
    public constructor {rcsFileName} {
        set fRcsFile $rcsFileName
    } {
    }
    
    # Delete self
    public method delete {} {
        ::itcl::delete object $this
    }

    # Generate a command to recreate this object
    public method serialize {} {
        error "not implemented"
        set serializeVersion SERIALIZE_VERSION
        foreach var [concat serializeVersion $SERIALIZE_FIELDS] {
            Serialize::serializeVar
        }
    }

    # Load serialized object. Cmd is the result of serialize
    public proc deserialize {cmd} {
        error "not implemented"
    }


    #added by galt
    # Compare revisions       
    public method compareRevs {r1 r2} {
	set r1s [split $r1 .]
	set r2s [split $r2 .]
	set r1l [llength $r1s] 
	set r2l [llength $r2s] 
        set i 0
	while {1} {
	  if {($i >= $r1l) && ($i >= $r2l)} { return 0 }
	  if {$i >= $r1l} { return -1 }
	  if {$i >= $r2l} { return  1 }
	  set n1 [lindex $r1s $i]
	  set n2 [lindex $r2s $i]
	  if {$n1 > $n2} { return  1 }	
	  if {$n1 < $n2} { return -1 }	
	  incr i 1
	}
	return 0
    }


    # Get the RCS file
    public method getRCSFile {} {
        return $fRcsFile
    }

    # Get the working file
    public method getWorkingFile {} {
        return $fWorkingFile
    }

    # Get the head
    public method getHead {} {
        return $fHead
    }

    # Get the branch
    public method getBranch {} {
        return $fBranch
    }

    # Test if a revSpec is a number or a tag
    private method isRevNumber {revSpec} {
        return [ctype digit [cindex $revSpec 0]]
    }

    # Lookup a tag.  If it doesn't exit, generate an error if check is 1
    # of return {} if check is 0. Magic tag HEAD is supported.
    private method lookupTag {tag {check 1}} {
        if {[cequal $tag HEAD]} {
            return [getHead]
        } elseif {[info exists fTagTable($tag)]} {
            return $fTagTable($tag)
        } elseif {$check} {
            error "tag \"$tag\" does not exist"
        } else {
            return {}
        }
    }

    # Translate a magic branch number to an actual revision number
    # If not a magic branch, return unchanged.
    public method translateMagicBranch {rev} {
        set revs [split $rev .]
        if {[lindex $revs end-1] == 0} {
            return [join [concat [lrange $revs 0 end-2] [lindex $revs end]] .]
        } else {
            return $rev
        }
    }
    
    # Deterimine if a revision or tag is a branch (x.x.0.x)
    public method isBranch {revSpec} {
        if {![isRevNumber $revSpec]} {
            set revSpec [lookupTag $revSpec]
        }
        return [expr [lindex [split $revSpec .] end-1] == 0]
    }

    # Get the list of tags
    public method getTags {} {
        return $fTags
    }

    # Determine if a tag exists.
    public method containsTag {tag} {
        return [info exists fTagTable($tag)]
    }

    # Look up a tags value by tag.  If not found, return {} if
    # check is 0, or an error if check is 1.
    # This does not translation magic branch numbers.
    public method getTag {tag {check 0}} {
        return [lookupTag $tag $check]
    }

    # Look up a tags value by tag.  If not found, return {} if
    # check is 0, or an error if check is 1.
    # Translates magic branch numbers.
    public method getTagRevision {tag {check 0}} {
        return [translateMagicBranch [lookupTag $tag $check]]
    }

    # Given a revision spec (tag or revision), translate it to
    # a revision. Invalid tags generate an error if check is 1,
    # otherwise returns empty. Branch tags are translated from
    # magic number to revision.  Branch numbers are passed through.
    public method toRevision {revSpec} {
        if {[isRevNumber $revSpec]} {
            return $revSpec
        } else {
            return [getTagRevision $revSpec]
        }
    }

    # Given a branch or revision number (or tag), return its parent.
    # A trunk revision returns {}
    public method getRevisionParent {revSpec} {
        set revs [split [toRevision $revSpec] .]
        if {[llength $revs] & 1} {
            # Branch number
            return [join [lrange $revs 0 end-1] .]
        } else {
            # Revision number
            return [join [lrange $revs 0 end-2] .]
        }
    }

    # Given a revision number (or tag), return its branch number.
    # Branch numbers are returned unchanged.  Head returns {}.
    public method getRevisionBranch {revSpec} {
        set revs [split [toRevision $revSpec] .]
        if {[llength $revs] == 2} {
            return {}  ;# Head
        } elseif {[llength $revs] & 1} {
            return [join $revs .]
        } else {
            # Revision number
            return [join [lrange $revs 0 end-1] .]
        }
    }

    # Given a branch tag or revision, get the first and last revision
    # numbers for the branch.  If no commits have been done on the
    # branch, return {}, otherwise return {firstRev lastRev}
    public method getBranchRevRange {branchTag} {
        #FIXME: This could be more general, returning the revision range
        #given any revSpec.
        if {![isBranch $branchTag]} {
            error "Not a branch tag: $branchTag"
        }
        set branch [getTagRevision $branchTag]
        
        # Search the revision list for the newest and oldest revisions
        # on the branch
        set newestRev {}
        set oldestRev {}
        foreach rev $fRevisions {
            if {[getRevisionBranch $rev] == $branch} {
                if {[lempty $newestRev]} {
                    set newestRev $rev
                }
                set oldestRev $rev
            }
        }
        if {[lempty $newestRev]} {
            return {}
        } else {
            return [list $oldestRev $newestRev]
        }
    }

    # find the previous revision, or 1.0 if none
    public method getPrevRev {rev} {
        set parts [split $rev .]
        set lastIdx [expr [llength $parts]-1]
        set last [lvarpop parts $lastIdx]
        if {$last == 1} {
            set prevRev [getRevisionParent $rev]
            if {[lempty $prevRev]} {
            # will generate diff for original commit
                set prevRev 1.0
            }
        } else {
            set prevRev [join [concat $parts [expr $last-1]] .]
        }
        return $prevRev
    }

    # Translate a revision specification:
    #   - Tag names are translated to revisions (HEAD is supported)
    #   - Revision numbers are returned as-is
    #   - Branch revisions are returned as the head.
    public method translateRevision {revSpec} {
        return [translateMagicBranch [toRevision $revSpec]]
    }

    # Get the list of revision numbers on this file
    public method getRevisions {} {
        return $fRevisions
    }

    # Get a revision record.
    # Returns: {rev dateTime author state comment}
    public method getRevision {revSpec} {
        set rev [translateRevision $revSpec]
        if {![info exists fRevisionTable($rev)]} {
            error "invalid revision specification: \"$revSpec\""
        }
        return $fRevisionTable($rev)
    }


    #added by galt
    # Find most-recent dead for handling resurrections
    #  or return "" if none. Scans backwards from to-tag rev passed in.
    public method mostRecentDead {rev} {
	while {$rev!="1.0"} {
    	    set frev [getRevision $rev]
	    set state [lindex $frev 3]
	    if {$state=="dead"} {
		return $rev
	    }
	    set rev [getPrevRev $rev]
	}
	return ""
    }
    
    # Convert to a printable string for debugging
    public method toString {{indent 0}} {
        set indentStr [replicate " " $indent]
        set indent2Str "$indentStr    "
        append str $indentStr "fRcsFile=$fRcsFile\n"
        foreach var {fWorkingFile fHead fBranch fKeywordSubst} {
            append str $indent2Str "$var=[set $var]\n"
        }
        foreach br [lsort [array names fBranchTable]] {
            append str $indent2Str "branch=[list $br $fBranchTable($br)]\n"
        }

        foreach tag $fTags {
            append str $indent2Str "tag=[list $tag $fTagTable($tag)]\n"
        }

        foreach rev $fRevisions {
            set revInfo "$rev $fRevisionTable($rev)"
            regsub -all {\n} $revInfo {\n} revInfo
            append str $indent2Str "rev=$revInfo\n"
        }
        return $str
    }
}


package require Itcl

#
# Class to do invoke CVS
#
::itcl::class CVSInvoke {
    private variable fRepository
    private variable fModule
    private variable fWorkDir
    private variable fDebug 0

    # Create for accessing the specified repository.  repository and module
    # maybe null depending on what commands are used.
    constructor {repository module workDir} {
        if {![lempty $repository]} {
            set fRepository $repository
        }
        if {![lempty $module]} {
            set fModule $module
        }
        set fWorkDir $workDir
    }

    # enable/disable debug tracing
    public method setDebug {val} {
        set fDebug $val
    }

    # evaluate a command in the working directory
    private method workDirEval {cmd} {
        set cwd [pwd]
        if {$fDebug} {
            puts stderr "cd $fWorkDir"
        }
        cd $fWorkDir
        if {[catch {
            set result [uplevel $cmd]
        } msg]} {
            cd $cwd
            error $msg $::errorInfo $::errorCode
        }
        cd $cwd
        return $result
    }

    # execute a cvs command 
    private method cvsExec {argv} {
        if {$fDebug} {
            puts stderr [join $argv]
        }
        return [eval exec $argv]
    }

    # open a pipe from a command
    private method cvsOpen {argv} {
        if {$fDebug} {
            puts stderr [join [concat | $argv]]
        }
        return [open [concat | $argv]]
    }

    # throw an error including a cvs commit
    private method throwError {cvsCmd} {
        error "$cvsCmd\n$::errorResult" $::errorInfo $::errorCode
    }
    
    # update the working directory
    public method update {} {
        set cmd [list cvs -Q update -kk -d]
        try_eval {
            workDirEval {
                cvsExec $cmd
            }
        } {
            throwError $cmd
        }
    }

    # read file info objects from a cvs log stream
    private method readFileInfo {chan {modulePath {}}} {
        set infoObjs {}
        while {![lempty [set obj [CVSFileInfo::readCvsLogRec $chan $modulePath]]]} {
            lappend infoObjs $obj
        }
        return $infoObjs
    }

    # do an rlog, return a list of CVSFileInfo objects
    public method getRLogInfo {} {
        # construct actually part to module dir, this is needed because we are
        # doing an rlog and need to compute the work directory
        set cwd [pwd]
        cd $fRepository/$fModule
        set modulePath [pwd]
        cd $cwd
        
        set cmd [list cvs -q -d $fRepository rlog $fModule]
        try_eval {
            set chan [cvsOpen $cmd]
            set infoObjs [readFileInfo $chan $modulePath]
            close $chan
        } {
            throwError $cmd
        } {
            catch {close $chan}
        }
        return $infoObjs
    }

    # do an log, return a list of CVSFileInfo objects
    public method getLogInfo {} {
        set cwd [pwd]
        
        set cmd [list cvs -q log]
        try_eval {
            workDirEval {
                set chan [cvsOpen $cmd]
                set infoObjs [readFileInfo $chan]
                close $chan
            }
        } {
            throwError $cmd
        } {
            catch {close $chan}
        }
        return $infoObjs
    }

    # return -r or -D for a revision
    private proc getRevFlag {rev} {
        if {[regexp {[-/]} $rev]} {
            return -D
        } else {
            return -r
        }
    }

    # do unified context diff on a file, requires a working directory
    # rev1 of 1.0 for a new file, rev maybe a file or date.  rev2 maybe
    # emptry.
    public method uniDiff {contextSize rev1 rev2 file} {
        # -N required to make -r 1.0 work
        set cmd [list cvs -q diff -bB -U $contextSize -kk -N]
        lappend cmd [getRevFlag $rev1] $rev1
        if {![lempty $rev2]} {
            lappend cmd [getRevFlag $rev2] $rev2
        }
        lappend cmd $file
        try_eval {
            workDirEval {
                # only way to determine if an error occured vs diff exit 1
                # is to check stderr
                set errTmp /var/tmp/err.[pid].tmp
                catch {
                    lappend cmd 2> $errTmp
                    cvsExec $cmd
                } diff
                if {![file exists $errTmp]} {
                    error $diff
                }
                if {[file size $errTmp] != 0} {
                    set errMsg [read_file $errTmp]
                    file delete $errTmp
                    error $errMsg
                }
                file delete $errTmp
            }
        } {
            throwError $cmd
        }
        regsub {child process exited abnormally$} $diff {} diff
        return $diff
    }
}


# returns {htmlLinks chgCnt}
proc mkUserDiffs {outDir fileInfo revInfo} {
    set title "[$fileInfo getWorkingFile] [lindex $revInfo 0]"
    set desc [htmlEncode [join [lrange $revInfo 0 3]]]
    set rev2 [lindex $revInfo 0]
    set rev1 [$fileInfo getPrevRev $rev2]
    return [mkDiffs $outDir $fileInfo $rev1 $rev2 $title $desc]
}

# write user file info
proc userFileReport {fh outDir user fileInfo revisions} {
    set totalChgCnt 0
    puts $fh "<LI> [$fileInfo getWorkingFile]"
    puts $fh "<UL>"
    foreach rev $revisions {
        set revInfo [$fileInfo getRevision $rev]
        lassign [mkUserDiffs $outDir $fileInfo $revInfo] diffLinks chgCnt
        puts $fh "<LI> $rev $diffLinks<br>"
        puts $fh [htmlEncode [lindex $revInfo 4]]
        incr totalChgCnt $chgCnt
    }
    puts $fh "</UL>"
    return $totalChgCnt
}

# write a report for a user in file and revision order
proc userReportByFile {outDir user userInfo} {
    set userDir $outDir/$user
    file mkdir $userDir
    set switchAnchor "switch to: <a href=\"index-by-commit.html\">grouped by commit view</a>, <a href=\"../../index.html\">user index</a><br>"

    set fh [open $userDir/index.html w]
    set title "$user: changes by file"
    puts $fh "<html><head><title>$title</title></head><body>"
    puts $fh "<h1>$title</h1>"
    puts $fh $switchAnchor

    #added by galt
    #puts $fh "<h3>changes from [fmtDate $::gStartDate] - [fmtDate $::gEndDate]</h3>"
    puts $fh "<h3>changes from $::gFromTag - $::gToTag</h3>"

    puts $fh "<ul>"
    set totalChgCnt 0
    foreach fileRec $userInfo {
        lassign $fileRec fileInfo revisions
        set chgCnt [userFileReport $fh $userDir $user $fileInfo $revisions]
        incr totalChgCnt $chgCnt
    }
    puts $fh "</ul>"
    puts $fh $switchAnchor
    puts $fh "</body></html>"
    close $fh
    return $totalChgCnt
}

# generate list of files by commit message
# {commit {{fileInfo revision} ..}
proc sortByCommit {userInfo} {
    # build tmp table
    foreach fileRec $userInfo {
        lassign $fileRec fileInfo revisions
        foreach rev $revisions {
            set revInfo [$fileInfo getRevision $rev]
            set commit [string trim [lindex $revInfo 4]]

            # save file for sort
            lappend byCommit($commit) [list [$fileInfo getWorkingFile] $fileInfo $rev]
            # save lowest date/time for commit sort
            set time [lindex $revInfo 1]
            if {![info exists commitTimes($commit)]
                || ([string compare $time $commitTimes($commit)] > 0)} {
                set commitTimes($commit) $time
            }
        }
    }

    # Sort commits by time
    set commitTimeList {}
    foreach commit [array names commitTimes] {
        lappend commitTimeList [list $commitTimes($commit) $commit]
    }
    set commitTimeList [lsort -index 0 $commitTimeList]

    # now create commit list, sort each commit by file name
    set commits {}
    foreach commitTime $commitTimeList {
        set commit [lindex $commitTime 1]
        set commitInfo {}
        foreach fileRec [lsort -index 0 $byCommit($commit)] {
            lappend commitInfo [lrange $fileRec 1 2]
        }
        lappend commits [list $commit $commitInfo]
    }
    return $commits
}

# write commit info
proc userCommitReport {fh outDir user commit commitInfo} {

    #added by galt
    #puts $fh "<LI> $commit"
    puts $fh "<LI> [htmlEncode $commit]"
    
    puts $fh "<UL>"

    foreach fileRec $commitInfo {
        lassign $fileRec fileInfo rev
        set revInfo [$fileInfo getRevision $rev]

	#added by galt
        #puts $fh "<LI> [$fileInfo getWorkingFile] $rev"
        #puts $fh [mkUserDiffs $outDir $fileInfo $revInfo]
        lassign [mkUserDiffs $outDir $fileInfo $revInfo] diffLinks chgCnt
        puts $fh "<LI> [$fileInfo getWorkingFile] $rev - $diffLinks"
	
    }
    puts $fh "</UL>"
}

# write a report for a user grouped by commit
proc userReportByCommit {outDir user userCommits} {
    set userDir $outDir/$user
    file mkdir $userDir
    set switchAnchor "switch to <a href=\"index.html\">grouped by file view</a>, <a href=\"../../index.html\">user index</a><br>"

    set fh [open $userDir/index-by-commit.html w]
    set title "$user: changes by commit"
    puts $fh "<html><head><title>$title</title></head><body>"
    puts $fh "<h1>$title</h1>"
    puts $fh $switchAnchor

    #added by galt
    #puts $fh "<h3>changes from [fmtDate $::gStartDate] - [fmtDate $::gEndDate]</h3>"
    puts $fh "<h3>changes from $::gFromTag - $::gToTag</h3>"

    puts $fh "<ul>"
    foreach commitRec $userCommits {
        userCommitReport $fh $userDir $user [lindex $commitRec 0] \
            [lindex $commitRec 1]
    }
    puts $fh "</ul>"
    puts $fh $switchAnchor
    puts $fh "</body></html>"
    close $fh
}

proc genUserReports {outDir userTableVar numChangedFiles} {
    upvar $userTableVar userTable
    progress "sorting commit information"
    foreach u [array names userTable] {
        set userCommits($u) [sortByCommit $userTable($u)]
    }
    progress "generating user reports"

    exec rm -rf $outDir
    file mkdir $outDir
    set index $outDir/index.html
    set fh [open $index.tmp w]
    set title "CVS changes by user"

    #added by galt
    #set title2 "[fmtDate $::gStartDate] to [fmtDate $::gEndDate]"
    set title2 "$::gFromTag to $::gToTag ($::gFromTagDate to $::gToTagDate)"
    
    puts $fh "<html><head><title>$title</title></head><body>"
    puts $fh "<h1>$title</h1>"
    puts $fh "<h2>$title2</h2>"
    puts $fh "<ul>"
    set totalChgCnt 0
    foreach u [lsort [array names userTable]] {
        set chgCnt [userReportByFile $outDir $u $userTable($u)]
        userReportByCommit $outDir $u $userCommits($u)
        incr totalChgCnt $chgCnt
        set numFiles [llength $userTable($u)]
        puts $fh "<LI> <A HREF=\"$u/index.html\">$u</A> - changed lines: $chgCnt, files: $numFiles"
    }
    puts $fh "</ul>"
    puts $fh "<ul>"
    puts $fh "<li> lines changed: $totalChgCnt"
    puts $fh "<li> files changed: $numChangedFiles"
    puts $fh "</ul>"
    puts $fh "</body></html>"
    close $fh
    file rename -force $index.tmp $index
    return $totalChgCnt
}


proc fileReport {fh outDir fileInfo fileRevs} {

    #added by galt
    #set rev1 [$fileInfo getRevisionParent [$fileInfo getTag $::gFromTag] ]
    #set rev2 [$fileInfo getRevisionParent [$fileInfo getTag $::gToTag]   ]

    #added by galt (new way using gWhichReport)
    set rev1 [$fileInfo getTag $::gFromTag]
    set rev2 [$fileInfo getTag $::gToTag]
    if {$::gWhichReport=="branch"} {
        set rev2 [$fileInfo getRevisionParent $rev2 ]
    } else {
        set rev1 [$fileInfo getRevisionParent $rev1 ]
    }

    
    set title "[$fileInfo getWorkingFile]"
    set desc {<ul>}
    foreach rev $fileRevs {
        set revInfo [$fileInfo getRevision $rev]

	#added by galt	
    	#lappend desc "<li> [join [lrange $revInfo 0 2]]<br>[htmlEncode [lindex $revInfo 4]]"
	set revP [$fileInfo getRevisionParent $rev]
	if {$revP == ""} { set revP $rev }
	if {[$fileInfo compareRevs $revP $rev1] > 0} {
	    lappend desc "<li> [join [lrange $revInfo 0 2]]<br>[htmlEncode [lindex $revInfo 4]]"
	}
    }
    lappend desc {</ul>}
    set desc [join $desc \n]

    #added by galt
    #lassign [mkDiffs $outDir $fileInfo [fmtDate $::gStartDate] {} $title $desc] diffLinks
    #set rev1 [fmtDate $::gStartDate]
    #set rev2 {}
    if {$rev1==""} {
     set rev1 "1.0"
    }
    lassign [mkDiffs $outDir $fileInfo $rev1 $rev2 $title $desc] diffLinks
    
    puts $fh "<LI> <code>[$fileInfo getWorkingFile]</code> - $diffLinks"
}

proc genFileReports {outDir fileTableVar lineChgCount} {
    upvar $fileTableVar fileTable

    progress "generating file reports"
    exec rm -rf $outDir
    file mkdir $outDir
    set index $outDir/index.html
    set fh [open $index.tmp w]
    set title "CVS changes by file"

    #added by galt
    #set title2 "[fmtDate $::gStartDate] to [fmtDate $::gEndDate]"
    set title2 "$::gFromTag to $::gToTag ($::gFromTagDate to $::gToTagDate)"
    
    puts $fh "<html><head><title>$title</title></head><body>"
    puts $fh "<h1>$title</h1>"
    puts $fh "<h2>$title2</h2>"
    puts $fh "<ul>"
    foreach f [lsort [array names fileTable]] {
        fileReport $fh $outDir [lindex $fileTable($f) 0] [lindex $fileTable($f) 1]
    }
    puts $fh "</ul>"
    puts $fh "<ul>"
    puts $fh "<li> lines changed: $lineChgCount"
    puts $fh "<li> files changed: [array size fileTable]"
    puts $fh "</ul>"
    puts $fh "</body></html>"
    close $fh
    file rename -force $index.tmp $index
}


set gUsage {cvs-reports [options] workdir outDir
   
options:
   -start date - Starting date, in the form 2003/02/30 or 2003-02-30
   -verbose - Generate progress messages
}

#
# Usage error.
#
proc usage {{msg {}}} {
    if {![lempty $msg]} {
        puts stderr "Error: $msg"
    }
    puts stderr $::gUsage
    exit 1
}

proc progress {msg} {
    if {$::gVerbose} {
        catch {
            puts "$msg"
            flush stdout
        }
    }
}

# convert date/time string to sec
proc cnvDateTime {dateStr} {
    # Tcl clock wants dates in form 2003-01-30
    regsub -all / $dateStr - dateStr
    return [clock scan $dateStr]
}

# format a date 
proc fmtDate {date} {
    return [clock format $date -format %F]
}

# encode a string as HTML test
proc htmlEncode {text} {
    regsub -all {&} $text {\&amp;} text
    regsub -all {<} $text {\&lt;} text
    regsub -all {>} $text {\&gt;} text
    return $text
}

# check rev date and if it's a HEAD revision
proc isRevSelected {fileInfo rev} {
    if {[$fileInfo isBranch $rev]} {
        return 0
    }

    #--- old way by date.  not used ---
    #set revRec [$fileInfo getRevision $rev]
    #return [expr [cnvDateTime [lindex $revRec 1]] >= $::gStartDate]

    # trying to ignore the specific revs of from/to and look at
    # the parent trunk revs instead, to use those for comparison
    set ftr [$fileInfo getTag $::gFromTag] 
    set ttr [$fileInfo getTag $::gToTag]   
   
    if {$::gWhichReport=="branch"} { 
	set ttr [$fileInfo getRevisionParent $ttr ]
    } else {
	set ftr [$fileInfo getRevisionParent $ftr ] 
    }
    ##used to be ftr,ttr were only x.x.x.x branch revisions
    ##but now they can be just trunk/tip x.x revisions also
    ## this compensates for those
    #if {$ftr==""} { set ftr [$fileInfo getTag $::gFromTag] }
    #if {$ttr==""} { set ttr [$fileInfo getTag $::gToTag] }
    ## however, the review tag is getting set on old files,
    ##  which does not happen by default with branch tags.
    ##  I have added -a to the review rtag command to suppress
    ##   the tagging of removed files in ./Attic.

    # Too new = no from- or to- tags (we don't want to see these)
    # New     = no from-tag but to-tag ok  
        # may be resurrected file, check rev against most-recent-dead scan back from ttr.
    # Current = both from- and -to tags ok
    # Recently removed = only from-tag, no to=tag
    # Removed long ago = no from- nor to- tags (we don't want to see these)
    
    if {$ttr==""} { 
	# is this a recently deleted rev? if not recent, skip
	if {$ftr==""} {
	    return 0
	}
	if {[$fileInfo compareRevs $rev $ftr] <= 0} {
	    return 0
	}
    } else {
    	if {[$fileInfo compareRevs $rev $ttr] >  0} {
    	    return 0
	}
    	if {$ftr==""} {
	    set ftr [$fileInfo mostRecentDead $ttr]
	}
    	if {$ftr!=""} {
    	    if {$ftr=="$ttr"} {
    		return 0
	    }
	    if {[$fileInfo compareRevs $rev $ftr] <= 0} {
    		return 0
    	    }
    	}
    }
   
    #debug
    #puts "[$fileInfo getWorkingFile] $rev"
    return 1
}

set gDiffStyle {
<STYLE type="text/css">
    .del  {background-color: red; font-weight: bold; padding-right: 100%;}
    .add  {background-color: lime; font-weight: bold; padding-right: 100%;}
    .repl {background-color: blue; font-weight: bold; padding-right: 100%;}
    .begin {background-color: yellow: bold; padding-right: 100%;}
</STYLE>
}

# HTML format a diff; desc should be HTML-ized.
proc mkHtmlDiff {outHtml fileInfo title desc diff} {
    # include rev and user
    set fh [open $outHtml.tmp w]
    puts $fh "<HTML><HEAD><TITLE>$title</TITLE>"
    puts $fh $::gDiffStyle
    puts $fh "</HEAD>"
    puts $fh "<BODY BGCOLOR=white>"
    puts $fh "<H1>$title</H1>"
    puts $fh $desc
    puts $fh "<PRE>"

    set diff [htmlEncode $diff]
    regsub -all -line {^!.*$} $diff {<SPAN class=repl>\0</SPAN>} diff
    regsub -all -line {^-.*$} $diff {<SPAN class=del>\0</SPAN>} diff
    regsub -all -line {^\+.*$} $diff {<SPAN class=add>\0</SPAN>} diff
    regsub -all -line {^@@.*$} $diff {<SPAN class=begin>\0</SPAN>} diff
    puts $fh $diff

    puts $fh "</PRE>"
    puts $fh "</BODY>"
    puts $fh "</HTML>"
    close $fh
    file rename -force $outHtml.tmp $outHtml
}

# Count number of changes lines
proc cntDiffChgs {diff} {
    set changes 0
    set adds 0
    set replaces 0
    set deletes 0
    set inChgBlock 0
    foreach line [split $diff \n] {
        set wasInChgBlock $inChgBlock
        switch -glob -- $line {
            +++* -
            ---* {
                set inChgBlock 0
            }
            +* {
                incr adds
                set inChgBlock 1
            }
            -* {
                incr deletes
                set inChgBlock 1
            }
            !* {
                incr replaces
                set inChgBlock 1
            }
            default {
                set inChgBlock 0
            }
        }
        if {$wasInChgBlock && !$inChgBlock} {
            incr changes [expr max($adds,$deletes)+$replaces]
            set adds 0
            set replaces 0
            set deletes 0
        }
    }
    if ($inChgBlock) {
        incr changes [expr max($adds,$deletes)+$replaces]
    }
    return $changes
}

# generate diffs for a revision as txt and html.  If it already
# exists, just return the files relative to outdir.  Type is
# context or full.  Also returns the diff text.
proc mkFileDiff {outDir fileInfo rev1 rev2 title desc type} {
    set srcFile [$fileInfo getWorkingFile]
    if {$type == "full"} {
        set relBase full/$srcFile.$rev1-$rev2
        set contentSize 1000000
    } else {
        set relBase context/$srcFile.$rev1-$rev2
        set contentSize 4
    }

    set outTxtRel $relBase.diff
    set outTxt $outDir/$outTxtRel

    set outHtmlRel $relBase.html
    set outHtml $outDir/$outHtmlRel

    if {[file exists $outTxt] || [file exists $outHtml]} {
	#added by galt
        #return [list $outTxtRel $outHtmlRel]
	if {$type == "context"} {
	    set diff [read_file $outTxt]
    	    return [list $outTxtRel $outHtmlRel $diff]
	} else {
	    return [list $outTxtRel $outHtmlRel]
	}
    }
    set diff [$::gCvsInvoke uniDiff $contentSize $rev1 $rev2 $srcFile]
    file mkdir [file dirname $outHtml]

    write_file $outTxt.tmp $diff 
    file rename -force $outTxt.tmp $outTxt
  
    mkHtmlDiff $outHtml $fileInfo $title $desc $diff
    return [list $outTxtRel $outHtmlRel $diff]
}

# Generate diffs and output the links.  Returns {htmlLinks chgCount}
proc mkDiffs {outDir fileInfo rev1 rev2 title desc} {
    lassign [mkFileDiff $outDir $fileInfo $rev1 $rev2 $title $desc context] \
        contextTxtRel contextHtmlRel diffs
    lassign [mkFileDiff $outDir $fileInfo $rev1 $rev2 $title $desc full] \
        fullTxtRel fullHtmlRel

    set chgCnt [cntDiffChgs $diffs]
    set links "lines changed: $chgCnt,\
               context: <A HREF=\"$contextHtmlRel\">html</A>,\
                    <A HREF=\"$contextTxtRel\">text</A>, \
               full: <A HREF=\"$fullHtmlRel\">html</A>,\
                    <A HREF=\"$fullTxtRel\">text</A>"
    return [list $links $chgCnt]
}

# select and sort by user add to use table
# user table are entries of {{fileObj {rev ...} ...}
# file table entries are {fileObj {rev ...}}
proc selectFileRevs {fileInfo userTableVar fileTableVar} {
    upvar $userTableVar userTable $fileTableVar fileTable
    
    # sort revisions out by users
    set selectRevs {}
    foreach rev [$fileInfo getRevisions] {
        if {[isRevSelected $fileInfo $rev]} {
            set user [lindex [$fileInfo getRevision $rev] 2]
            lappend byUser($user) $rev
            lappend selectRevs $rev
        }
    }

    # add to tables
    foreach u [array names byUser] {
        lappend userTable($u) [list $fileInfo $byUser($u)]
    }
    if {![lempty $selectRevs]} {
        set fileTable([$fileInfo getWorkingFile]) [list $fileInfo $selectRevs]
    }
}

proc makeIndexPage {outDir} {
    file mkdir $outDir
    set index $outDir/index.html
    set fh [open $index.tmp w]
    set title "CVS changes: $::gModule"

    #added by galt
    #set title2 "[fmtDate $::gStartDate] to [fmtDate $::gEndDate]"
    set title2 "$::gFromTag to $::gToTag ($::gFromTagDate to $::gToTagDate)"
    
    puts $fh "<html><head><title></title></head><body>"
    puts $fh "<h1>$title</h1>"
    puts $fh "<h2>$title2</h2>"
    puts $fh {
<ul>
<li><a href="user/index.html">Changes by user</a>
<li><a href="file/index.html">Changes by file</a>
</ul>
<h2>Overview</h2>
<h3>Content diffs</h3>
Two types of diffs are produced:
<ul>
<li> Unified contexts diffs - shows the changes and surrounding
     few lines.
<li> Full diffs - unified diffs in context of the entire file. 
     For user reports, this is the file after the change,
     not the current version of the file.  For file reports,
     this is all changes over the time period.
</ul>
The diffs are in two formats:
<ul>
<li> HTML with changes color coded.
<li> ASCII text, useful for emacs.
</ul>

<p>
The <code>changed</code> line counts are derived by examining the diffs.
blocks of deletes followed by inserts are considered replacements,
so the change count is the larger of the delete count and add count.

<h3>Rebuilding the reports</h3>
 To rebuild this report, run:

<!-- #added by galt -->
<!-- #<blockquote><CODE>cvs-reports-build <em>startDate</em></CODE></blockquote> -->
<blockquote><CODE>cvs-reports-delta <em>FromTag ToTag FromTagDate ToTagDate mode</em></CODE></blockquote>

</body>
</html>
}
    close $fh
    file rename -force $index.tmp $index
}

proc genReports {outDir infoList} {
    progress "sorting revision information"
    foreach f $infoList {
        selectFileRevs $f userTable fileTable
    }

    exec rm -rf $outDir/user.new
    set lineChgCount [genUserReports $outDir/user.new userTable [array size fileTable]]
    exec rm -rf $outDir/user
    file rename $outDir/user.new $outDir/user

    exec rm -rf $outDir/file.new
    genFileReports $outDir/file.new fileTable $lineChgCount
    exec rm -rf $outDir/file
    file rename $outDir/file.new $outDir/file

    makeIndexPage $outDir
}

#
# Entry
#

# added by galt
# these will be calculated from value(s) passed in
set gToTag   "v66_branch"
set gFromTag "v65_branch"
set gWhichReport "none"

set gStartDate 0
set gCgiProgress 0
set gVerbose 0
set gRebuildCgi {}
set debug 0

# added by galt
# testing - lets see what happens when we turn debug on!
#set debug 1  - spits out detail to std out, but mostly post my interest area

while {[string match -* [lindex $argv 0]]} {
    set opt [lvarpop argv]
    switch -- $opt {
        -from {  #added by galt
            if {[lempty $argv]} {
                usage "-from requires an argument"
            }
            set gFromTag [lvarpop argv]
        }
        -to {  #added by galt
            if {[lempty $argv]} {
                usage "-to requires an argument"
            }
            set gToTag [lvarpop argv]
	}
        -fromDate {  #added by galt
            if {[lempty $argv]} {
                usage "-fromDate requires an argument"
            }
            set gFromTagDate [lvarpop argv]
        }
        -toDate {  #added by galt
            if {[lempty $argv]} {
                usage "-toDate requires an argument"
            }
            set gToTagDate [lvarpop argv]
	}
        -whichReport {  #added by galt
            if {[lempty $argv]} {
                usage "-whichReport requires an argument"
            }
            set gWhichReport [lvarpop argv]
	}
        -start {
            if {[lempty $argv]} {
                usage "-start requires an argument"
            }
            set startDateStr [lvarpop argv]
            set gStartDate [cnvDateTime $startDateStr]
        }
        -cgi-progress {
            set gCgiProgress 1
            set gVerbose 1
        }
        -verbose {
            set gVerbose 1
        }
        -rebuild-cgi {
            if {[lempty $argv]} {
		# typofix by galt -cgs
                usage "-rebuild-cgi requires an argument"
            }
            set gRebuildCgi [lvarpop argv]
        }
        -debug {
            set debug 1
        }
        default {
            usage "Invalid option \"$opt\""
        }
    }
}


if { ($gWhichReport != "branch") && ($gWhichReport != "review") } {
    usage "wrong report type $gWhichReport, should be branch or review"
}


if {[llength $argv] != 2} {
    usage "wrong \# args"
}
lassign $argv workDir outDir
set gEndDate [clock seconds]
if {![file isdir $workDir]} {
    usage "workdir does not exists: $workDir"
}

# make sure directory write perms are maintained
umask 0002

# get module from workDir for use in messages
set gModule [string trim [read_file $workDir/CVS/Repository]]

set gCvsInvoke [CVSInvoke \#auto {} $gModule $workDir]
$gCvsInvoke setDebug $debug

# added by galt
progress "starting from-tag $gFromTag"
progress "  ending   to-tag $gToTag"
progress "starting from-tag-date $gFromTagDate"
progress "  ending   to-tag-date $gToTagDate"
progress " which report: $gWhichReport"

# update the working directory (if rdiff supported -U, we wouldn't need
# a working dir

progress "updating cvs working directory for $gModule"
$gCvsInvoke update

progress "collecting cvs change logs for $gModule"
set infoList [$gCvsInvoke getLogInfo]

genReports $outDir $infoList

progress "cvs report generation complete"

